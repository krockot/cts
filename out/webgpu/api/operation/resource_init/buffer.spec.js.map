{"version":3,"sources":["../../../../../src/webgpu/api/operation/resource_init/buffer.spec.ts"],"names":["makeTestGroup","assert","unreachable","GPUConst","GPUTest","checkElementsEqual","getTextureCopyLayout","description","kMapModeOptions","MapMode","READ","WRITE","kBufferUsagesForMappedAtCreationTests","BufferUsage","COPY_DST","MAP_READ","COPY_SRC","MAP_WRITE","F","GetBufferUsageFromMapMode","mapMode","GPUMapMode","GPUBufferUsage","CheckGPUBufferContent","buffer","bufferUsage","expectedData","mapAsync","expectOK","Uint8Array","getMappedRange","unmap","expectGPUBufferValuesEqual","TestBufferZeroInitInBindGroup","computeShaderModule","bufferOffset","boundBufferSize","computePipeline","device","createComputePipeline","compute","module","entryPoint","outputTexture","createTexture","format","size","usage","GPUTextureUsage","STORAGE","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","offset","createView","encoder","createCommandEncoder","computePass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","expectSingleColor","exp","R","G","B","A","expectedBufferdata","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","params","bufferSize","appliedOffset","createBuffer","copySize","writeData","i","writeBuffer","readData","expect","beginSubcases","mapSize","mappedData","mappedAtCreation","mapped","mappedSize","textureSize","width","height","depthOrArrayLayers","dstTextureFormat","dstTexture","srcBufferSize","byteLength","srcBufferUsage","srcBuffer","copyBufferToTexture","bytesPerRow","rowsPerImage","texture","expectedSrcBufferData","QUERY_RESOLVE","dstBuffer","querySet","createQuerySet","type","count","resolveQuerySet","expectedBufferData","filter","arrayLayerCount","copyMipLevel","srcTextureFormat","srcTexture","RENDER_ATTACHMENT","mipLevelCount","mipLevel","dstBufferSize","Math","abs","layer","renderPass","beginRenderPass","colorAttachments","view","baseArrayLayer","baseMipLevel","loadValue","r","b","a","storeOp","max","copyTextureToBuffer","mipSize","y","x","UNIFORM","createShaderModule","code"],"mappings":"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","sourcesContent":["import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { GPUConst } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { checkElementsEqual } from '../../../util/check_contents.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\n\nexport const description = `\nTest uninitialized buffers are initialized to zero when read\n(or read-written, e.g. with depth write or atomics).\n\nNote that:\n-  We don't need 'copy_buffer_to_buffer_copy_destination' here because there has already been an\n   operation test 'command_buffer.copyBufferToBuffer.single' that provides the same functionality.\n\nTODO:\nTest the buffers whose first usage is being used:\n- as vertex / index buffer\n- as indirect buffer\n`;\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kBufferUsagesForMappedAtCreationTests = [\n  GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ,\n  GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.MAP_WRITE,\n  GPUConst.BufferUsage.COPY_SRC,\n];\n\nclass F extends GPUTest {\n  GetBufferUsageFromMapMode(mapMode: GPUMapModeFlags): number {\n    switch (mapMode) {\n      case GPUMapMode.READ:\n        return GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      case GPUMapMode.WRITE:\n        return GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      default:\n        unreachable();\n        return 0;\n    }\n  }\n\n  async CheckGPUBufferContent(\n    buffer: GPUBuffer,\n    bufferUsage: GPUBufferUsageFlags,\n    expectedData: Uint8Array\n  ): Promise<void> {\n    // We can only check the buffer contents with t.expectGPUBufferValuesEqual() when the buffer\n    // usage contains COPY_SRC.\n    if (bufferUsage & GPUBufferUsage.MAP_READ) {\n      await buffer.mapAsync(GPUMapMode.READ);\n      this.expectOK(checkElementsEqual(new Uint8Array(buffer.getMappedRange()), expectedData));\n      buffer.unmap();\n    } else {\n      assert((bufferUsage & GPUBufferUsage.COPY_SRC) !== 0);\n      this.expectGPUBufferValuesEqual(buffer, expectedData);\n    }\n  }\n\n  TestBufferZeroInitInBindGroup(\n    computeShaderModule: GPUShaderModule,\n    buffer: GPUBuffer,\n    bufferOffset: number,\n    boundBufferSize: number\n  ): void {\n    const computePipeline = this.device.createComputePipeline({\n      compute: {\n        module: computeShaderModule,\n        entryPoint: 'main',\n      },\n    });\n    const outputTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE,\n    });\n    const bindGroup = this.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer,\n            offset: bufferOffset,\n            size: boundBufferSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatch(1);\n    computePass.endPass();\n    this.queue.submit([encoder.finish()]);\n\n    this.expectSingleColor(outputTexture, 'rgba8unorm', {\n      size: [1, 1, 1],\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n\n    // Verify the remaining part of the buffer is also cleared to 0.\n    if (bufferOffset > 0) {\n      const expectedBufferdata = new Uint8Array(boundBufferSize + bufferOffset);\n      this.expectGPUBufferValuesEqual(buffer, expectedBufferdata);\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('partial_write_buffer')\n  .desc(\n    `Verify when we upload data to a part of a buffer with writeBuffer() just after the creation of\nthe buffer, the remaining part of that buffer will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('offset', [0, 8, -12]))\n  .fn(async t => {\n    const { offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const copySize = 12;\n    const writeData = new Uint8Array(copySize);\n    const expectedData = new Uint8Array(bufferSize);\n    for (let i = 0; i < copySize; ++i) {\n      expectedData[appliedOffset + i] = writeData[i] = i + 1;\n    }\n    t.queue.writeBuffer(buffer, appliedOffset, writeData, 0);\n\n    t.expectGPUBufferValuesEqual(buffer, expectedData);\n  });\n\ng.test('map_whole_buffer')\n  .desc(\n    `Verify when we map the whole range of a mappable GPUBuffer to a typed array buffer just after\ncreating the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer itself\nhave already been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const bufferSize = 32;\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    await buffer.mapAsync(mapMode);\n    const readData = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(readData[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('map_partial_buffer')\n  .desc(\n    `Verify when we map a subrange of a mappable GPUBuffer to a typed array buffer just after the\ncreation of the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer have\nalready been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions).beginSubcases().combine('offset', [0, 8, -16]))\n  .fn(async t => {\n    const { mapMode, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mapSize = 16;\n      await buffer.mapAsync(mapMode, appliedOffset, mapSize);\n      const mappedData = new Uint8Array(buffer.getMappedRange(appliedOffset, mapSize));\n      for (let i = 0; i < mapSize; ++i) {\n        t.expect(mappedData[i] === 0);\n        if (mapMode === GPUMapMode.WRITE) {\n          mappedData[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_whole_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at the whole range of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u => u.combine('bufferUsage', kBufferUsagesForMappedAtCreationTests))\n  .fn(async t => {\n    const { bufferUsage } = t.params;\n\n    const bufferSize = 32;\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const mapped = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(mapped[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_partial_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at a subrange of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u =>\n    u\n      .combine('bufferUsage', kBufferUsagesForMappedAtCreationTests)\n      .beginSubcases()\n      .combine('offset', [0, 8, -16])\n  )\n  .fn(async t => {\n    const { bufferUsage, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mappedSize = 12;\n      const mapped = new Uint8Array(buffer.getMappedRange(appliedOffset, mappedSize));\n      for (let i = 0; i < mappedSize; ++i) {\n        t.expect(mapped[i] === 0);\n        if (!(bufferUsage & GPUBufferUsage.MAP_READ)) {\n          mapped[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_buffer_copy_source')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToBuffer(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .fn(async t => {\n    const bufferSize = 32;\n    const bufferUsage = GPUBufferUsage.COPY_SRC;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    // copyBufferToBuffer() is called inside t.CheckGPUBufferContent().\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_texture')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToTexture(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 8]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const textureSize = { width: 8, height: 8, depthOrArrayLayers: 1 };\n    const dstTextureFormat = 'rgba8unorm';\n\n    const dstTexture = t.device.createTexture({\n      size: textureSize,\n      format: dstTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    const layout = getTextureCopyLayout(dstTextureFormat, '2d', [\n      textureSize.width,\n      textureSize.height,\n      textureSize.depthOrArrayLayers,\n    ]);\n    const srcBufferSize = layout.byteLength + bufferOffset;\n    const srcBufferUsage = GPUBufferUsage.COPY_SRC;\n    const srcBuffer = t.device.createBuffer({\n      size: srcBufferSize,\n      usage: srcBufferUsage,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyBufferToTexture(\n      {\n        buffer: srcBuffer,\n        offset: bufferOffset,\n        bytesPerRow: layout.bytesPerRow,\n        rowsPerImage: layout.rowsPerImage,\n      },\n      { texture: dstTexture },\n      textureSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Verify the contents in srcBuffer are all 0.\n    const expectedSrcBufferData = new Uint8Array(srcBufferSize);\n    await t.CheckGPUBufferContent(srcBuffer, srcBufferUsage, expectedSrcBufferData);\n\n    // Verify the texels in dstTexture are all 0.\n    t.expectSingleColor(dstTexture, dstTextureFormat, {\n      size: [textureSize.width, textureSize.height, textureSize.depthOrArrayLayers],\n      exp: { R: 0.0, G: 0.0, B: 0.0, A: 0.0 },\n    });\n  });\n\ng.test('resolve_query_set_to_partial_buffer')\n  .desc(\n    `Verify when we resolve a query set into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const bufferSize = bufferOffset + 8;\n    const bufferUsage = GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE;\n    const dstBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const querySet = t.device.createQuerySet({ type: 'occlusion', count: 1 });\n    const encoder = t.device.createCommandEncoder();\n    encoder.resolveQuerySet(querySet, 0, 1, dstBuffer, bufferOffset);\n    t.queue.submit([encoder.finish()]);\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(dstBuffer, bufferUsage, expectedBufferData);\n  });\n\ng.test('copy_texture_to_partial_buffer')\n  .desc(\n    `Verify when we copy from a GPUTexture into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('bufferOffset', [0, 8, -16])\n      .combine('arrayLayerCount', [1, 3])\n      .combine('copyMipLevel', [0, 2])\n      .combine('rowsPerImage', [16, 20])\n      .filter(t => {\n        // We don't need to test the copies that will cover the whole GPUBuffer.\n        return !(t.bufferOffset === 0 && t.rowsPerImage === 16);\n      })\n  )\n  .fn(async t => {\n    const { bufferOffset, arrayLayerCount, copyMipLevel, rowsPerImage } = t.params;\n    const srcTextureFormat = 'r8uint';\n    const textureSize = [32, 16, arrayLayerCount] as const;\n\n    const srcTexture = t.device.createTexture({\n      format: srcTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      size: textureSize,\n      mipLevelCount: copyMipLevel + 1,\n    });\n\n    const bytesPerRow = 256;\n    const layout = getTextureCopyLayout(srcTextureFormat, '2d', textureSize, {\n      mipLevel: copyMipLevel,\n      bytesPerRow,\n      rowsPerImage,\n    });\n\n    const dstBufferSize = layout.byteLength + Math.abs(bufferOffset);\n    const dstBuffer = t.device.createBuffer({\n      size: dstBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n\n    // Initialize srcTexture\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: srcTexture.createView({\n              baseArrayLayer: layer,\n              arrayLayerCount: 1,\n              baseMipLevel: copyMipLevel,\n            }),\n            loadValue: { r: layer + 1, g: 0, b: 0, a: 0 },\n            storeOp: 'store',\n          },\n        ],\n      });\n      renderPass.endPass();\n    }\n\n    // Do texture-to-buffer copy\n    const appliedOffset = Math.max(bufferOffset, 0);\n    encoder.copyTextureToBuffer(\n      { texture: srcTexture, mipLevel: copyMipLevel },\n      { buffer: dstBuffer, offset: appliedOffset, bytesPerRow, rowsPerImage },\n      layout.mipSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Check if the contents of the destination bufer are what we expect.\n    const expectedData = new Uint8Array(dstBufferSize);\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      for (let y = 0; y < layout.mipSize[1]; ++y) {\n        for (let x = 0; x < layout.mipSize[0]; ++x) {\n          expectedData[appliedOffset + layer * bytesPerRow * rowsPerImage + y * bytesPerRow + x] =\n            layer + 1;\n        }\n      }\n    }\n    t.expectGPUBufferValuesEqual(dstBuffer, expectedData);\n  });\n\ng.test('uniform_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a uniform buffer just after the creation of that GPUBuffer,\n    all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.UNIFORM,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n  [[block]] struct UBO {\n      value : vec4<u32>;\n  };\n  [[group(0), binding(0)]] var<uniform> ubo : UBO;\n  [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n  [[stage(compute), workgroup_size(1)]] fn main() {\n      if (all(ubo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n      } else {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n      }\n  }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('readonly_storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a read-only storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    [[block]] struct SSBO {\n        value : vec4<u32>;\n    };\n    [[group(0), binding(0)]] var<storage, read> ssbo : SSBO;\n    [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    [[stage(compute), workgroup_size(1)]] fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    [[block]] struct SSBO {\n        value : vec4<u32>;\n    };\n    [[group(0), binding(0)]] var<storage, read_write> ssbo : SSBO;\n    [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    [[stage(compute), workgroup_size(1)]] fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n"],"file":"buffer.spec.js"}