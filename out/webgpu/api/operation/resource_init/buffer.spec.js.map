{"version":3,"sources":["../../../../../src/webgpu/api/operation/resource_init/buffer.spec.ts"],"names":["makeTestGroup","assert","unreachable","GPUConst","GPUTest","checkElementsEqual","getTextureCopyLayout","description","kMapModeOptions","MapMode","READ","WRITE","kBufferUsagesForMappedAtCreationTests","BufferUsage","COPY_DST","MAP_READ","COPY_SRC","MAP_WRITE","F","GetBufferUsageFromMapMode","mapMode","GPUMapMode","GPUBufferUsage","CheckGPUBufferContent","buffer","bufferUsage","expectedData","mapAsync","expectOK","Uint8Array","getMappedRange","unmap","expectGPUBufferValuesEqual","TestBufferZeroInitInBindGroup","computeShaderModule","bufferOffset","boundBufferSize","computePipeline","device","createComputePipeline","compute","module","entryPoint","outputTexture","createTexture","format","size","usage","GPUTextureUsage","STORAGE","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","offset","createView","encoder","createCommandEncoder","computePass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","CheckBufferAndOutputTexture","CreateRenderPipelineForTest","vertexShaderModule","testVertexBuffer","renderPipelineDescriptor","vertex","fragment","createShaderModule","code","targets","primitive","topology","buffers","arrayStride","attributes","shaderLocation","createRenderPipeline","RecordInitializeTextureColor","texture","color","renderPass","beginRenderPass","colorAttachments","view","loadValue","storeOp","bufferSize","outputTextureSize","outputTextureColor","R","G","B","A","expectSingleColor","exp","expectedBufferData","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","params","appliedOffset","createBuffer","copySize","writeData","i","writeBuffer","readData","expect","beginSubcases","mapSize","mappedData","mappedAtCreation","mapped","mappedSize","textureSize","dstTextureFormat","dstTexture","srcBufferSize","byteLength","srcBufferUsage","srcBuffer","copyBufferToTexture","bytesPerRow","rowsPerImage","QUERY_RESOLVE","dstBuffer","querySet","createQuerySet","type","count","resolveQuerySet","filter","arrayLayerCount","copyMipLevel","srcTextureFormat","srcTexture","RENDER_ATTACHMENT","mipLevelCount","mipLevel","dstBufferSize","Math","abs","layer","baseArrayLayer","baseMipLevel","r","b","a","max","copyTextureToBuffer","mipSize","y","x","UNIFORM","renderPipeline","vertexBuffer","VERTEX","setVertexBuffer","draw","indexBuffer","INDEX","setIndexBuffer","drawIndexed","test_indexed_draw","kDrawIndirectParametersSize","kDrawIndexedIndirectParametersSize","indirectBuffer","INDIRECT","undefined","drawIndexedIndirect","drawIndirect","kDispatchIndirectParametersSize","dispatchIndirect"],"mappings":"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","sourcesContent":["import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { GPUConst } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { checkElementsEqual } from '../../../util/check_contents.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\nimport { PerTexelComponent } from '../../../util/texture/texel_data.js';\n\nexport const description = `\nTest uninitialized buffers are initialized to zero when read\n(or read-written, e.g. with depth write or atomics).\n\nNote that:\n-  We don't need 'copy_buffer_to_buffer_copy_destination' here because there has already been an\n   operation test 'command_buffer.copyBufferToBuffer.single' that provides the same functionality.\n`;\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kBufferUsagesForMappedAtCreationTests = [\n  GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ,\n  GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.MAP_WRITE,\n  GPUConst.BufferUsage.COPY_SRC,\n];\n\nclass F extends GPUTest {\n  GetBufferUsageFromMapMode(mapMode: GPUMapModeFlags): number {\n    switch (mapMode) {\n      case GPUMapMode.READ:\n        return GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      case GPUMapMode.WRITE:\n        return GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      default:\n        unreachable();\n        return 0;\n    }\n  }\n\n  async CheckGPUBufferContent(\n    buffer: GPUBuffer,\n    bufferUsage: GPUBufferUsageFlags,\n    expectedData: Uint8Array\n  ): Promise<void> {\n    // We can only check the buffer contents with t.expectGPUBufferValuesEqual() when the buffer\n    // usage contains COPY_SRC.\n    if (bufferUsage & GPUBufferUsage.MAP_READ) {\n      await buffer.mapAsync(GPUMapMode.READ);\n      this.expectOK(checkElementsEqual(new Uint8Array(buffer.getMappedRange()), expectedData));\n      buffer.unmap();\n    } else {\n      assert((bufferUsage & GPUBufferUsage.COPY_SRC) !== 0);\n      this.expectGPUBufferValuesEqual(buffer, expectedData);\n    }\n  }\n\n  TestBufferZeroInitInBindGroup(\n    computeShaderModule: GPUShaderModule,\n    buffer: GPUBuffer,\n    bufferOffset: number,\n    boundBufferSize: number\n  ): void {\n    const computePipeline = this.device.createComputePipeline({\n      compute: {\n        module: computeShaderModule,\n        entryPoint: 'main',\n      },\n    });\n    const outputTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE,\n    });\n    const bindGroup = this.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer,\n            offset: bufferOffset,\n            size: boundBufferSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatch(1);\n    computePass.endPass();\n    this.queue.submit([encoder.finish()]);\n\n    this.CheckBufferAndOutputTexture(buffer, boundBufferSize + bufferOffset, outputTexture);\n  }\n\n  CreateRenderPipelineForTest(\n    vertexShaderModule: GPUShaderModule,\n    testVertexBuffer: boolean\n  ): GPURenderPipeline {\n    const renderPipelineDescriptor: GPURenderPipelineDescriptor = {\n      vertex: {\n        module: vertexShaderModule,\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n        [[stage(fragment)]]\n        fn main([[location(0)]] i_color : vec4<f32>) -> [[location(0)]] vec4<f32> {\n            return i_color;\n        }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n    };\n    if (testVertexBuffer) {\n      renderPipelineDescriptor.vertex.buffers = [\n        {\n          arrayStride: 16,\n          attributes: [{ format: 'float32x4', offset: 0, shaderLocation: 0 }],\n        },\n      ];\n    }\n\n    return this.device.createRenderPipeline(renderPipelineDescriptor);\n  }\n\n  RecordInitializeTextureColor(\n    encoder: GPUCommandEncoder,\n    texture: GPUTexture,\n    color: GPUColor\n  ): void {\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: texture.createView(),\n          loadValue: color,\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.endPass();\n  }\n\n  CheckBufferAndOutputTexture(\n    buffer: GPUBuffer,\n    bufferSize: number,\n    outputTexture: GPUTexture,\n    outputTextureSize: [number, number, number] = [1, 1, 1],\n    outputTextureColor: PerTexelComponent<number> = { R: 0.0, G: 1.0, B: 0.0, A: 1.0 }\n  ): void {\n    this.expectSingleColor(outputTexture, 'rgba8unorm', {\n      size: outputTextureSize,\n      exp: outputTextureColor,\n    });\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    this.expectGPUBufferValuesEqual(buffer, expectedBufferData);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('partial_write_buffer')\n  .desc(\n    `Verify when we upload data to a part of a buffer with writeBuffer() just after the creation of\nthe buffer, the remaining part of that buffer will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('offset', [0, 8, -12]))\n  .fn(async t => {\n    const { offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const copySize = 12;\n    const writeData = new Uint8Array(copySize);\n    const expectedData = new Uint8Array(bufferSize);\n    for (let i = 0; i < copySize; ++i) {\n      expectedData[appliedOffset + i] = writeData[i] = i + 1;\n    }\n    t.queue.writeBuffer(buffer, appliedOffset, writeData, 0);\n\n    t.expectGPUBufferValuesEqual(buffer, expectedData);\n  });\n\ng.test('map_whole_buffer')\n  .desc(\n    `Verify when we map the whole range of a mappable GPUBuffer to a typed array buffer just after\ncreating the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer itself\nhave already been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const bufferSize = 32;\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    await buffer.mapAsync(mapMode);\n    const readData = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(readData[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('map_partial_buffer')\n  .desc(\n    `Verify when we map a subrange of a mappable GPUBuffer to a typed array buffer just after the\ncreation of the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer have\nalready been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions).beginSubcases().combine('offset', [0, 8, -16]))\n  .fn(async t => {\n    const { mapMode, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mapSize = 16;\n      await buffer.mapAsync(mapMode, appliedOffset, mapSize);\n      const mappedData = new Uint8Array(buffer.getMappedRange(appliedOffset, mapSize));\n      for (let i = 0; i < mapSize; ++i) {\n        t.expect(mappedData[i] === 0);\n        if (mapMode === GPUMapMode.WRITE) {\n          mappedData[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_whole_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at the whole range of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u => u.combine('bufferUsage', kBufferUsagesForMappedAtCreationTests))\n  .fn(async t => {\n    const { bufferUsage } = t.params;\n\n    const bufferSize = 32;\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const mapped = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(mapped[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_partial_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at a subrange of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u =>\n    u\n      .combine('bufferUsage', kBufferUsagesForMappedAtCreationTests)\n      .beginSubcases()\n      .combine('offset', [0, 8, -16])\n  )\n  .fn(async t => {\n    const { bufferUsage, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mappedSize = 12;\n      const mapped = new Uint8Array(buffer.getMappedRange(appliedOffset, mappedSize));\n      for (let i = 0; i < mappedSize; ++i) {\n        t.expect(mapped[i] === 0);\n        if (!(bufferUsage & GPUBufferUsage.MAP_READ)) {\n          mapped[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_buffer_copy_source')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToBuffer(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .fn(async t => {\n    const bufferSize = 32;\n    const bufferUsage = GPUBufferUsage.COPY_SRC;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    // copyBufferToBuffer() is called inside t.CheckGPUBufferContent().\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_texture')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToTexture(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 8]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const textureSize: [number, number, number] = [8, 8, 1];\n    const dstTextureFormat = 'rgba8unorm';\n\n    const dstTexture = t.device.createTexture({\n      size: textureSize,\n      format: dstTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    const layout = getTextureCopyLayout(dstTextureFormat, '2d', textureSize);\n    const srcBufferSize = layout.byteLength + bufferOffset;\n    const srcBufferUsage = GPUBufferUsage.COPY_SRC;\n    const srcBuffer = t.device.createBuffer({\n      size: srcBufferSize,\n      usage: srcBufferUsage,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyBufferToTexture(\n      {\n        buffer: srcBuffer,\n        offset: bufferOffset,\n        bytesPerRow: layout.bytesPerRow,\n        rowsPerImage: layout.rowsPerImage,\n      },\n      { texture: dstTexture },\n      textureSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(srcBuffer, srcBufferSize, dstTexture, textureSize, {\n      R: 0.0,\n      G: 0.0,\n      B: 0.0,\n      A: 0.0,\n    });\n  });\n\ng.test('resolve_query_set_to_partial_buffer')\n  .desc(\n    `Verify when we resolve a query set into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const bufferSize = bufferOffset + 8;\n    const bufferUsage = GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE;\n    const dstBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const querySet = t.device.createQuerySet({ type: 'occlusion', count: 1 });\n    const encoder = t.device.createCommandEncoder();\n    encoder.resolveQuerySet(querySet, 0, 1, dstBuffer, bufferOffset);\n    t.queue.submit([encoder.finish()]);\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(dstBuffer, bufferUsage, expectedBufferData);\n  });\n\ng.test('copy_texture_to_partial_buffer')\n  .desc(\n    `Verify when we copy from a GPUTexture into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('bufferOffset', [0, 8, -16])\n      .combine('arrayLayerCount', [1, 3])\n      .combine('copyMipLevel', [0, 2])\n      .combine('rowsPerImage', [16, 20])\n      .filter(t => {\n        // We don't need to test the copies that will cover the whole GPUBuffer.\n        return !(t.bufferOffset === 0 && t.rowsPerImage === 16);\n      })\n  )\n  .fn(async t => {\n    const { bufferOffset, arrayLayerCount, copyMipLevel, rowsPerImage } = t.params;\n    const srcTextureFormat = 'r8uint';\n    const textureSize = [32, 16, arrayLayerCount] as const;\n\n    const srcTexture = t.device.createTexture({\n      format: srcTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      size: textureSize,\n      mipLevelCount: copyMipLevel + 1,\n    });\n\n    const bytesPerRow = 256;\n    const layout = getTextureCopyLayout(srcTextureFormat, '2d', textureSize, {\n      mipLevel: copyMipLevel,\n      bytesPerRow,\n      rowsPerImage,\n    });\n\n    const dstBufferSize = layout.byteLength + Math.abs(bufferOffset);\n    const dstBuffer = t.device.createBuffer({\n      size: dstBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n\n    // Initialize srcTexture\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: srcTexture.createView({\n              baseArrayLayer: layer,\n              arrayLayerCount: 1,\n              baseMipLevel: copyMipLevel,\n            }),\n            loadValue: { r: layer + 1, g: 0, b: 0, a: 0 },\n            storeOp: 'store',\n          },\n        ],\n      });\n      renderPass.endPass();\n    }\n\n    // Do texture-to-buffer copy\n    const appliedOffset = Math.max(bufferOffset, 0);\n    encoder.copyTextureToBuffer(\n      { texture: srcTexture, mipLevel: copyMipLevel },\n      { buffer: dstBuffer, offset: appliedOffset, bytesPerRow, rowsPerImage },\n      layout.mipSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Check if the contents of the destination bufer are what we expect.\n    const expectedData = new Uint8Array(dstBufferSize);\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      for (let y = 0; y < layout.mipSize[1]; ++y) {\n        for (let x = 0; x < layout.mipSize[0]; ++x) {\n          expectedData[appliedOffset + layer * bytesPerRow * rowsPerImage + y * bytesPerRow + x] =\n            layer + 1;\n        }\n      }\n    }\n    t.expectGPUBufferValuesEqual(dstBuffer, expectedData);\n  });\n\ng.test('uniform_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a uniform buffer just after the creation of that GPUBuffer,\n    all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.UNIFORM,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n  [[block]] struct UBO {\n      value : vec4<u32>;\n  };\n  [[group(0), binding(0)]] var<uniform> ubo : UBO;\n  [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n  [[stage(compute), workgroup_size(1)]] fn main() {\n      if (all(ubo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n      } else {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n      }\n  }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('readonly_storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a read-only storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    [[block]] struct SSBO {\n        value : vec4<u32>;\n    };\n    [[group(0), binding(0)]] var<storage, read> ssbo : SSBO;\n    [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    [[stage(compute), workgroup_size(1)]] fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    [[block]] struct SSBO {\n        value : vec4<u32>;\n    };\n    [[group(0), binding(0)]] var<storage, read_write> ssbo : SSBO;\n    [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    [[stage(compute), workgroup_size(1)]] fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('vertex_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a vertex buffer just after the creation of that\n  GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n      struct VertexOut {\n        [[location(0)]] color : vec4<f32>;\n        [[builtin(position)]] position : vec4<f32>;\n      };\n\n      [[stage(vertex)]] fn main([[location(0)]] pos : vec4<f32>) -> VertexOut {\n        var output : VertexOut;\n        if (all(pos == vec4<f32>(0.0, 0.0, 0.0, 0.0))) {\n          output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        } else {\n          output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n        }\n        output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        return output;\n      }`,\n      }),\n      true\n    );\n\n    const bufferSize = 16 + bufferOffset;\n    const vertexBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setVertexBuffer(0, vertexBuffer, bufferOffset);\n    renderPass.setPipeline(renderPipeline);\n    renderPass.draw(1);\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(vertexBuffer, bufferSize, outputTexture);\n  });\n\ng.test('index_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as an index buffer just after the creation of that\nGPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      [[location(0)]] color : vec4<f32>;\n      [[builtin(position)]] position : vec4<f32>;\n    };\n\n    [[stage(vertex)]]\n    fn main([[builtin(vertex_index)]] VertexIndex : u32) -> VertexOut {\n      var output : VertexOut;\n      if (VertexIndex == 0u) {\n        output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n      } else {\n        output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      }\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    // The size of GPUBuffer must be at least 4.\n    const bufferSize = 4 + bufferOffset;\n    const indexBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', bufferOffset, 4);\n    renderPass.drawIndexed(1);\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    t.CheckBufferAndOutputTexture(indexBuffer, bufferSize, outputTexture);\n  });\n\ng.test('indirect_buffer_for_draw_indirect')\n  .desc(\n    `Verify when we use a GPUBuffer as an indirect buffer for drawIndirect() or\ndrawIndexedIndirect() just after the creation of that GPUBuffer, all the contents in that GPUBuffer\nhave been initialized to 0.`\n  )\n  .params(u =>\n    u.combine('test_indexed_draw', [true, false]).beginSubcases().combine('bufferOffset', [0, 16])\n  )\n  .fn(async t => {\n    const { test_indexed_draw, bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      [[location(0)]] color : vec4<f32>;\n      [[builtin(position)]] position : vec4<f32>;\n    };\n\n    [[stage(vertex)]] fn main() -> VertexOut {\n      var output : VertexOut;\n      output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    const kDrawIndirectParametersSize = 16;\n    const kDrawIndexedIndirectParametersSize = 20;\n    const bufferSize =\n      Math.max(kDrawIndirectParametersSize, kDrawIndexedIndirectParametersSize) + bufferOffset;\n    const indirectBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    // Initialize outputTexture to green.\n    const encoder = t.device.createCommandEncoder();\n    t.RecordInitializeTextureColor(encoder, outputTexture, { r: 0.0, g: 1.0, b: 0.0, a: 1.0 });\n\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: 'load',\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n\n    let indexBuffer = undefined;\n    if (test_indexed_draw) {\n      indexBuffer = t.device.createBuffer({\n        size: 4,\n        usage: GPUBufferUsage.INDEX,\n      });\n      renderPass.setIndexBuffer(indexBuffer, 'uint16');\n      renderPass.drawIndexedIndirect(indirectBuffer, bufferOffset);\n    } else {\n      renderPass.drawIndirect(indirectBuffer, bufferOffset);\n    }\n\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    // The indirect buffer should be lazily cleared to 0, so we actually draw nothing and the color\n    // attachment will keep its original color (green) after we end the render pass.\n    t.CheckBufferAndOutputTexture(indirectBuffer, bufferSize, outputTexture);\n  });\n\ng.test('indirect_buffer_for_dispatch_indirect')\n  .desc(\n    `Verify when we use a GPUBuffer as an indirect buffer for dispatchIndirect() just after the\ncreation of that GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const computePipeline = t.device.createComputePipeline({\n      compute: {\n        module: t.device.createShaderModule({\n          code: `\n        [[group(0), binding(0)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n        [[stage(compute), workgroup_size(1)]] fn main() {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }`,\n        }),\n        entryPoint: 'main',\n      },\n    });\n\n    const kDispatchIndirectParametersSize = 12;\n    const bufferSize = kDispatchIndirectParametersSize + bufferOffset;\n    const indirectBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE,\n    });\n\n    // Initialize outputTexture to green.\n    const encoder = t.device.createCommandEncoder();\n    t.RecordInitializeTextureColor(encoder, outputTexture, { r: 0.0, g: 1.0, b: 0.0, a: 1.0 });\n\n    const bindGroup = t.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    // The indirect buffer should be lazily cleared to 0, so we actually don't execute the compute\n    // shader and the output texture should keep its original color (green).\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatchIndirect(indirectBuffer, bufferOffset);\n    computePass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    // The indirect buffer should be lazily cleared to 0, so we actually draw nothing and the color\n    // attachment will keep its original color (green) after we end the compute pass.\n    t.CheckBufferAndOutputTexture(indirectBuffer, bufferSize, outputTexture);\n  });\n"],"file":"buffer.spec.js"}