{"version":3,"sources":["../../../../../src/webgpu/api/operation/resource_init/buffer.spec.ts"],"names":["makeTestGroup","assert","unreachable","GPUConst","GPUTest","checkElementsEqual","getTextureCopyLayout","description","kMapModeOptions","MapMode","READ","WRITE","kBufferUsagesForMappedAtCreationTests","BufferUsage","COPY_DST","MAP_READ","COPY_SRC","MAP_WRITE","F","GetBufferUsageFromMapMode","mapMode","GPUMapMode","GPUBufferUsage","CheckGPUBufferContent","buffer","bufferUsage","expectedData","mapAsync","expectOK","Uint8Array","getMappedRange","unmap","expectGPUBufferValuesEqual","TestBufferZeroInitInBindGroup","computeShaderModule","bufferOffset","boundBufferSize","computePipeline","device","createComputePipeline","compute","module","entryPoint","outputTexture","createTexture","format","size","usage","GPUTextureUsage","STORAGE","bindGroup","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","offset","createView","encoder","createCommandEncoder","computePass","beginComputePass","setBindGroup","setPipeline","dispatch","endPass","queue","submit","finish","expectSingleColor","exp","R","G","B","A","expectedBufferdata","CreateRenderPipelineForVertexAndIndexBufferInitTest","vertexShaderModule","testVertexBuffer","renderPipelineDescriptor","vertex","fragment","createShaderModule","code","targets","primitive","topology","buffers","arrayStride","attributes","shaderLocation","createRenderPipeline","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","params","bufferSize","appliedOffset","createBuffer","copySize","writeData","i","writeBuffer","readData","expect","beginSubcases","mapSize","mappedData","mappedAtCreation","mapped","mappedSize","textureSize","width","height","depthOrArrayLayers","dstTextureFormat","dstTexture","srcBufferSize","byteLength","srcBufferUsage","srcBuffer","copyBufferToTexture","bytesPerRow","rowsPerImage","texture","expectedSrcBufferData","QUERY_RESOLVE","dstBuffer","querySet","createQuerySet","type","count","resolveQuerySet","expectedBufferData","filter","arrayLayerCount","copyMipLevel","srcTextureFormat","srcTexture","RENDER_ATTACHMENT","mipLevelCount","mipLevel","dstBufferSize","Math","abs","layer","renderPass","beginRenderPass","colorAttachments","view","baseArrayLayer","baseMipLevel","loadValue","r","b","a","storeOp","max","copyTextureToBuffer","mipSize","y","x","UNIFORM","renderPipeline","vertexBuffer","VERTEX","setVertexBuffer","draw","indexBuffer","INDEX","setIndexBuffer","drawIndexed"],"mappings":";AAAA;AACA,GADA,SAASA,aAAT,QAA8B,4CAA9B,CACA,SAASC,MAAT,EAAiBC,WAAjB,QAAoC,iCAApC,CACA,SAASC,QAAT,QAAyB,uBAAzB;AACA,SAASC,OAAT,QAAwB,sBAAxB;AACA,SAASC,kBAAT,QAAmC,iCAAnC;AACA,SAASC,oBAAT,QAAqC,iCAArC;;AAEA,OAAO,MAAMC,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAXO;;AAaP,MAAMC,eAAe,GAAG,CAACL,QAAQ,CAACM,OAAT,CAAiBC,IAAlB,EAAwBP,QAAQ,CAACM,OAAT,CAAiBE,KAAzC,CAAxB;AACA,MAAMC,qCAAqC,GAAG;AAC5CT,QAAQ,CAACU,WAAT,CAAqBC,QAArB,GAAgCX,QAAQ,CAACU,WAAT,CAAqBE,QADT;AAE5CZ,QAAQ,CAACU,WAAT,CAAqBG,QAArB,GAAgCb,QAAQ,CAACU,WAAT,CAAqBI,SAFT;AAG5Cd,QAAQ,CAACU,WAAT,CAAqBG,QAHuB,CAA9C;;;AAMA,MAAME,CAAN,SAAgBd,OAAhB,CAAwB;AACtBe,EAAAA,yBAAyB,CAACC,OAAD,EAAmC;AAC1D,YAAQA,OAAR;AACE,WAAKC,UAAU,CAACX,IAAhB;AACE,eAAOY,cAAc,CAACR,QAAf,GAA0BQ,cAAc,CAACP,QAAhD;AACF,WAAKM,UAAU,CAACV,KAAhB;AACE,eAAOW,cAAc,CAACN,QAAf,GAA0BM,cAAc,CAACL,SAAhD;AACF;AACEf,QAAAA,WAAW;AACX,eAAO,CAAP,CAPJ;;AASD;;AAED,QAAMqB,qBAAN;AACEC,EAAAA,MADF;AAEEC,EAAAA,WAFF;AAGEC,EAAAA,YAHF;AAIiB;AACf;AACA;AACA,QAAID,WAAW,GAAGH,cAAc,CAACP,QAAjC,EAA2C;AACzC,YAAMS,MAAM,CAACG,QAAP,CAAgBN,UAAU,CAACX,IAA3B,CAAN;AACA,WAAKkB,QAAL,CAAcvB,kBAAkB,CAAC,IAAIwB,UAAJ,CAAeL,MAAM,CAACM,cAAP,EAAf,CAAD,EAA0CJ,YAA1C,CAAhC;AACAF,MAAAA,MAAM,CAACO,KAAP;AACD,KAJD,MAIO;AACL9B,MAAAA,MAAM,CAAC,CAACwB,WAAW,GAAGH,cAAc,CAACN,QAA9B,MAA4C,CAA7C,CAAN;AACA,WAAKgB,0BAAL,CAAgCR,MAAhC,EAAwCE,YAAxC;AACD;AACF;;AAEDO,EAAAA,6BAA6B;AAC3BC,EAAAA,mBAD2B;AAE3BV,EAAAA,MAF2B;AAG3BW,EAAAA,YAH2B;AAI3BC,EAAAA,eAJ2B;AAKrB;AACN,UAAMC,eAAe,GAAG,KAAKC,MAAL,CAAYC,qBAAZ,CAAkC;AACxDC,MAAAA,OAAO,EAAE;AACPC,QAAAA,MAAM,EAAEP,mBADD;AAEPQ,QAAAA,UAAU,EAAE,MAFL,EAD+C,EAAlC,CAAxB;;;AAMA,UAAMC,aAAa,GAAG,KAAKL,MAAL,CAAYM,aAAZ,CAA0B;AAC9CC,MAAAA,MAAM,EAAE,YADsC;AAE9CC,MAAAA,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAFwC;AAG9CC,MAAAA,KAAK,EAAEC,eAAe,CAAChC,QAAhB,GAA2BgC,eAAe,CAACC,OAHJ,EAA1B,CAAtB;;AAKA,UAAMC,SAAS,GAAG,KAAKZ,MAAL,CAAYa,eAAZ,CAA4B;AAC5CC,MAAAA,MAAM,EAAEf,eAAe,CAACgB,kBAAhB,CAAmC,CAAnC,CADoC;AAE5CC,MAAAA,OAAO,EAAE;AACP;AACEC,QAAAA,OAAO,EAAE,CADX;AAEEC,QAAAA,QAAQ,EAAE;AACRhC,UAAAA,MADQ;AAERiC,UAAAA,MAAM,EAAEtB,YAFA;AAGRW,UAAAA,IAAI,EAAEV,eAHE,EAFZ,EADO;;;AASP;AACEmB,QAAAA,OAAO,EAAE,CADX;AAEEC,QAAAA,QAAQ,EAAEb,aAAa,CAACe,UAAd,EAFZ,EATO,CAFmC,EAA5B,CAAlB;;;;;AAkBA,UAAMC,OAAO,GAAG,KAAKrB,MAAL,CAAYsB,oBAAZ,EAAhB;AACA,UAAMC,WAAW,GAAGF,OAAO,CAACG,gBAAR,EAApB;AACAD,IAAAA,WAAW,CAACE,YAAZ,CAAyB,CAAzB,EAA4Bb,SAA5B;AACAW,IAAAA,WAAW,CAACG,WAAZ,CAAwB3B,eAAxB;AACAwB,IAAAA,WAAW,CAACI,QAAZ,CAAqB,CAArB;AACAJ,IAAAA,WAAW,CAACK,OAAZ;AACA,SAAKC,KAAL,CAAWC,MAAX,CAAkB,CAACT,OAAO,CAACU,MAAR,EAAD,CAAlB;;AAEA,SAAKC,iBAAL,CAAuB3B,aAAvB,EAAsC,YAAtC,EAAoD;AAClDG,MAAAA,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAD4C;AAElDyB,MAAAA,GAAG,EAAE,EAAEC,CAAC,EAAE,GAAL,EAAUC,CAAC,EAAE,GAAb,EAAkBC,CAAC,EAAE,GAArB,EAA0BC,CAAC,EAAE,GAA7B,EAF6C,EAApD;;;AAKA;AACA,QAAIxC,YAAY,GAAG,CAAnB,EAAsB;AACpB,YAAMyC,kBAAkB,GAAG,IAAI/C,UAAJ,CAAeO,eAAe,GAAGD,YAAjC,CAA3B;AACA,WAAKH,0BAAL,CAAgCR,MAAhC,EAAwCoD,kBAAxC;AACD;AACF;;AAEDC,EAAAA,mDAAmD;AACjDC,EAAAA,kBADiD;AAEjDC,EAAAA,gBAFiD;AAG9B;AACnB,UAAMC,wBAAqD,GAAG;AAC5DC,MAAAA,MAAM,EAAE;AACNxC,QAAAA,MAAM,EAAEqC,kBADF;AAENpC,QAAAA,UAAU,EAAE,MAFN,EADoD;;AAK5DwC,MAAAA,QAAQ,EAAE;AACRzC,QAAAA,MAAM,EAAE,KAAKH,MAAL,CAAY6C,kBAAZ,CAA+B;AACrCC,UAAAA,IAAI,EAAG;AACjB;AACA;AACA;AACA,UAL+C,EAA/B,CADA;;AAQR1C,QAAAA,UAAU,EAAE,MARJ;AASR2C,QAAAA,OAAO,EAAE,CAAC,EAAExC,MAAM,EAAE,YAAV,EAAD,CATD,EALkD;;AAgB5DyC,MAAAA,SAAS,EAAE;AACTC,QAAAA,QAAQ,EAAE,YADD,EAhBiD,EAA9D;;;AAoBA,QAAIR,gBAAJ,EAAsB;AACpBC,MAAAA,wBAAwB,CAACC,MAAzB,CAAgCO,OAAhC,GAA0C;AACxC;AACEC,QAAAA,WAAW,EAAE,EADf;AAEEC,QAAAA,UAAU,EAAE,CAAC,EAAE7C,MAAM,EAAE,WAAV,EAAuBY,MAAM,EAAE,CAA/B,EAAkCkC,cAAc,EAAE,CAAlD,EAAD,CAFd,EADwC,CAA1C;;;AAMD;;AAED,WAAO,KAAKrD,MAAL,CAAYsD,oBAAZ,CAAiCZ,wBAAjC,CAAP;AACD,GAvHqB;;;AA0HxB,OAAO,MAAMa,CAAC,GAAG7F,aAAa,CAACkB,CAAD,CAAvB;;AAEP2E,CAAC,CAACC,IAAF,CAAO,sBAAP;AACGC,IADH;AAEK;AACL,wEAHA;;AAKGC,kBALH,CAKsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,QAAV,EAAoB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,EAAR,CAApB,CAL3B;AAMGC,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAE3C,MAAF,KAAa2C,CAAC,CAACC,MAArB;AACA,QAAMC,UAAU,GAAG,EAAnB;AACA,QAAMC,aAAa,GAAG9C,MAAM,IAAI,CAAV,GAAcA,MAAd,GAAuB6C,UAAU,GAAG7C,MAA1D;;AAEA,QAAMjC,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnC1D,IAAAA,IAAI,EAAEwD,UAD6B;AAEnCvD,IAAAA,KAAK,EAAEzB,cAAc,CAACN,QAAf,GAA0BM,cAAc,CAACR,QAFb,EAAtB,CAAf;;;AAKA,QAAM2F,QAAQ,GAAG,EAAjB;AACA,QAAMC,SAAS,GAAG,IAAI7E,UAAJ,CAAe4E,QAAf,CAAlB;AACA,QAAM/E,YAAY,GAAG,IAAIG,UAAJ,CAAeyE,UAAf,CAArB;AACA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAApB,EAA8B,EAAEE,CAAhC,EAAmC;AACjCjF,IAAAA,YAAY,CAAC6E,aAAa,GAAGI,CAAjB,CAAZ,GAAkCD,SAAS,CAACC,CAAD,CAAT,GAAeA,CAAC,GAAG,CAArD;AACD;AACDP,EAAAA,CAAC,CAACjC,KAAF,CAAQyC,WAAR,CAAoBpF,MAApB,EAA4B+E,aAA5B,EAA2CG,SAA3C,EAAsD,CAAtD;;AAEAN,EAAAA,CAAC,CAACpE,0BAAF,CAA6BR,MAA7B,EAAqCE,YAArC;AACD,CAzBH;;AA2BAmE,CAAC,CAACC,IAAF,CAAO,kBAAP;AACGC,IADH;AAEK;AACL;AACA,oCAJA;;AAMGM,MANH,CAMUJ,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,SAAV,EAAqB1F,eAArB,CANf;AAOG2F,EAPH,CAOM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEhF,OAAF,KAAcgF,CAAC,CAACC,MAAtB;;AAEA,QAAMC,UAAU,GAAG,EAAnB;AACA,QAAM7E,WAAW,GAAG2E,CAAC,CAACjF,yBAAF,CAA4BC,OAA5B,CAApB;AACA,QAAMI,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnC1D,IAAAA,IAAI,EAAEwD,UAD6B;AAEnCvD,IAAAA,KAAK,EAAEtB,WAF4B,EAAtB,CAAf;;;AAKA,QAAMD,MAAM,CAACG,QAAP,CAAgBP,OAAhB,CAAN;AACA,QAAMyF,QAAQ,GAAG,IAAIhF,UAAJ,CAAeL,MAAM,CAACM,cAAP,EAAf,CAAjB;AACA,OAAK,IAAI6E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,UAApB,EAAgC,EAAEK,CAAlC,EAAqC;AACnCP,IAAAA,CAAC,CAACU,MAAF,CAASD,QAAQ,CAACF,CAAD,CAAR,KAAgB,CAAzB;AACD;AACDnF,EAAAA,MAAM,CAACO,KAAP;;AAEA,QAAML,YAAY,GAAG,IAAIG,UAAJ,CAAeyE,UAAf,CAArB;AACA,QAAMF,CAAC,CAAC7E,qBAAF,CAAwBC,MAAxB,EAAgCC,WAAhC,EAA6CC,YAA7C,CAAN;AACD,CA1BH;;AA4BAmE,CAAC,CAACC,IAAF,CAAO,oBAAP;AACGC,IADH;AAEK;AACL;AACA,+BAJA;;AAMGM,MANH,CAMUJ,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,SAAV,EAAqB1F,eAArB,EAAsCuG,aAAtC,GAAsDb,OAAtD,CAA8D,QAA9D,EAAwE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,EAAR,CAAxE,CANf;AAOGC,EAPH,CAOM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEhF,OAAF,EAAWqC,MAAX,KAAsB2C,CAAC,CAACC,MAA9B;AACA,QAAMC,UAAU,GAAG,EAAnB;AACA,QAAMC,aAAa,GAAG9C,MAAM,IAAI,CAAV,GAAcA,MAAd,GAAuB6C,UAAU,GAAG7C,MAA1D;;AAEA,QAAMhC,WAAW,GAAG2E,CAAC,CAACjF,yBAAF,CAA4BC,OAA5B,CAApB;AACA,QAAMI,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnC1D,IAAAA,IAAI,EAAEwD,UAD6B;AAEnCvD,IAAAA,KAAK,EAAEtB,WAF4B,EAAtB,CAAf;;;AAKA,QAAMC,YAAY,GAAG,IAAIG,UAAJ,CAAeyE,UAAf,CAArB;AACA;AACE,UAAMU,OAAO,GAAG,EAAhB;AACA,UAAMxF,MAAM,CAACG,QAAP,CAAgBP,OAAhB,EAAyBmF,aAAzB,EAAwCS,OAAxC,CAAN;AACA,UAAMC,UAAU,GAAG,IAAIpF,UAAJ,CAAeL,MAAM,CAACM,cAAP,CAAsByE,aAAtB,EAAqCS,OAArC,CAAf,CAAnB;AACA,SAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGK,OAApB,EAA6B,EAAEL,CAA/B,EAAkC;AAChCP,MAAAA,CAAC,CAACU,MAAF,CAASG,UAAU,CAACN,CAAD,CAAV,KAAkB,CAA3B;AACA,UAAIvF,OAAO,KAAKC,UAAU,CAACV,KAA3B,EAAkC;AAChCsG,QAAAA,UAAU,CAACN,CAAD,CAAV,GAAgBjF,YAAY,CAAC6E,aAAa,GAAGI,CAAjB,CAAZ,GAAkCA,CAAC,GAAG,CAAtD;AACD;AACF;AACDnF,IAAAA,MAAM,CAACO,KAAP;AACD;;AAED,QAAMqE,CAAC,CAAC7E,qBAAF,CAAwBC,MAAxB,EAAgCC,WAAhC,EAA6CC,YAA7C,CAAN;AACD,CAjCH;;AAmCAmE,CAAC,CAACC,IAAF,CAAO,iCAAP;AACGC,IADH;AAEK;AACL;AACA,0FAJA;;AAMGM,MANH,CAMUJ,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,aAAV,EAAyBtF,qCAAzB,CANf;AAOGuF,EAPH,CAOM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAE3E,WAAF,KAAkB2E,CAAC,CAACC,MAA1B;;AAEA,QAAMC,UAAU,GAAG,EAAnB;AACA,QAAM9E,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnCU,IAAAA,gBAAgB,EAAE,IADiB;AAEnCpE,IAAAA,IAAI,EAAEwD,UAF6B;AAGnCvD,IAAAA,KAAK,EAAEtB,WAH4B,EAAtB,CAAf;;;AAMA,QAAM0F,MAAM,GAAG,IAAItF,UAAJ,CAAeL,MAAM,CAACM,cAAP,EAAf,CAAf;AACA,OAAK,IAAI6E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,UAApB,EAAgC,EAAEK,CAAlC,EAAqC;AACnCP,IAAAA,CAAC,CAACU,MAAF,CAASK,MAAM,CAACR,CAAD,CAAN,KAAc,CAAvB;AACD;AACDnF,EAAAA,MAAM,CAACO,KAAP;;AAEA,QAAML,YAAY,GAAG,IAAIG,UAAJ,CAAeyE,UAAf,CAArB;AACA,QAAMF,CAAC,CAAC7E,qBAAF,CAAwBC,MAAxB,EAAgCC,WAAhC,EAA6CC,YAA7C,CAAN;AACD,CAzBH;;AA2BAmE,CAAC,CAACC,IAAF,CAAO,mCAAP;AACGC,IADH;AAEK;AACL;AACA,0FAJA;;AAMGM,MANH,CAMU,CAAAJ,CAAC;AACPA,CAAC;AACEC,OADH,CACW,aADX,EAC0BtF,qCAD1B;AAEGmG,aAFH;AAGGb,OAHH,CAGW,QAHX,EAGqB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,EAAR,CAHrB,CAPJ;;AAYGC,EAZH,CAYM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAE3E,WAAF,EAAegC,MAAf,KAA0B2C,CAAC,CAACC,MAAlC;AACA,QAAMC,UAAU,GAAG,EAAnB;AACA,QAAMC,aAAa,GAAG9C,MAAM,IAAI,CAAV,GAAcA,MAAd,GAAuB6C,UAAU,GAAG7C,MAA1D;;AAEA,QAAMjC,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnCU,IAAAA,gBAAgB,EAAE,IADiB;AAEnCpE,IAAAA,IAAI,EAAEwD,UAF6B;AAGnCvD,IAAAA,KAAK,EAAEtB,WAH4B,EAAtB,CAAf;;;AAMA,QAAMC,YAAY,GAAG,IAAIG,UAAJ,CAAeyE,UAAf,CAArB;AACA;AACE,UAAMc,UAAU,GAAG,EAAnB;AACA,UAAMD,MAAM,GAAG,IAAItF,UAAJ,CAAeL,MAAM,CAACM,cAAP,CAAsByE,aAAtB,EAAqCa,UAArC,CAAf,CAAf;AACA,SAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,UAApB,EAAgC,EAAET,CAAlC,EAAqC;AACnCP,MAAAA,CAAC,CAACU,MAAF,CAASK,MAAM,CAACR,CAAD,CAAN,KAAc,CAAvB;AACA,UAAI,EAAElF,WAAW,GAAGH,cAAc,CAACP,QAA/B,CAAJ,EAA8C;AAC5CoG,QAAAA,MAAM,CAACR,CAAD,CAAN,GAAYjF,YAAY,CAAC6E,aAAa,GAAGI,CAAjB,CAAZ,GAAkCA,CAAC,GAAG,CAAlD;AACD;AACF;AACDnF,IAAAA,MAAM,CAACO,KAAP;AACD;;AAED,QAAMqE,CAAC,CAAC7E,qBAAF,CAAwBC,MAAxB,EAAgCC,WAAhC,EAA6CC,YAA7C,CAAN;AACD,CArCH;;AAuCAmE,CAAC,CAACC,IAAF,CAAO,mCAAP;AACGC,IADH;AAEK;AACL,wFAHA;;AAKGI,EALH,CAKM,MAAMC,CAAN,IAAW;AACb,QAAME,UAAU,GAAG,EAAnB;AACA,QAAM7E,WAAW,GAAGH,cAAc,CAACN,QAAnC;AACA,QAAMQ,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnC1D,IAAAA,IAAI,EAAEwD,UAD6B;AAEnCvD,IAAAA,KAAK,EAAEtB,WAF4B,EAAtB,CAAf;;;AAKA,QAAMC,YAAY,GAAG,IAAIG,UAAJ,CAAeyE,UAAf,CAArB;AACA;AACA,QAAMF,CAAC,CAAC7E,qBAAF,CAAwBC,MAAxB,EAAgCC,WAAhC,EAA6CC,YAA7C,CAAN;AACD,CAhBH;;AAkBAmE,CAAC,CAACC,IAAF,CAAO,wBAAP;AACGC,IADH;AAEK;AACL,yFAHA;;AAKGC,kBALH,CAKsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,cAAV,EAA0B,CAAC,CAAD,EAAI,CAAJ,CAA1B,CAL3B;AAMGC,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEjE,YAAF,KAAmBiE,CAAC,CAACC,MAA3B;AACA,QAAMgB,WAAW,GAAG,EAAEC,KAAK,EAAE,CAAT,EAAYC,MAAM,EAAE,CAApB,EAAuBC,kBAAkB,EAAE,CAA3C,EAApB;AACA,QAAMC,gBAAgB,GAAG,YAAzB;;AAEA,QAAMC,UAAU,GAAGtB,CAAC,CAAC9D,MAAF,CAASM,aAAT,CAAuB;AACxCE,IAAAA,IAAI,EAAEuE,WADkC;AAExCxE,IAAAA,MAAM,EAAE4E,gBAFgC;AAGxC1E,IAAAA,KAAK,EAAEC,eAAe,CAAChC,QAAhB,GAA2BgC,eAAe,CAAClC,QAHV,EAAvB,CAAnB;;AAKA,QAAMsC,MAAM,GAAG9C,oBAAoB,CAACmH,gBAAD,EAAmB,IAAnB,EAAyB;AAC1DJ,EAAAA,WAAW,CAACC,KAD8C;AAE1DD,EAAAA,WAAW,CAACE,MAF8C;AAG1DF,EAAAA,WAAW,CAACG,kBAH8C,CAAzB,CAAnC;;AAKA,QAAMG,aAAa,GAAGvE,MAAM,CAACwE,UAAP,GAAoBzF,YAA1C;AACA,QAAM0F,cAAc,GAAGvG,cAAc,CAACN,QAAtC;AACA,QAAM8G,SAAS,GAAG1B,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACtC1D,IAAAA,IAAI,EAAE6E,aADgC;AAEtC5E,IAAAA,KAAK,EAAE8E,cAF+B,EAAtB,CAAlB;;;AAKA,QAAMlE,OAAO,GAAGyC,CAAC,CAAC9D,MAAF,CAASsB,oBAAT,EAAhB;AACAD,EAAAA,OAAO,CAACoE,mBAAR;AACE;AACEvG,IAAAA,MAAM,EAAEsG,SADV;AAEErE,IAAAA,MAAM,EAAEtB,YAFV;AAGE6F,IAAAA,WAAW,EAAE5E,MAAM,CAAC4E,WAHtB;AAIEC,IAAAA,YAAY,EAAE7E,MAAM,CAAC6E,YAJvB,EADF;;AAOE,IAAEC,OAAO,EAAER,UAAX,EAPF;AAQEL,EAAAA,WARF;;AAUAjB,EAAAA,CAAC,CAACjC,KAAF,CAAQC,MAAR,CAAe,CAACT,OAAO,CAACU,MAAR,EAAD,CAAf;;AAEA;AACA,QAAM8D,qBAAqB,GAAG,IAAItG,UAAJ,CAAe8F,aAAf,CAA9B;AACA,QAAMvB,CAAC,CAAC7E,qBAAF,CAAwBuG,SAAxB,EAAmCD,cAAnC,EAAmDM,qBAAnD,CAAN;;AAEA;AACA/B,EAAAA,CAAC,CAAC9B,iBAAF,CAAoBoD,UAApB,EAAgCD,gBAAhC,EAAkD;AAChD3E,IAAAA,IAAI,EAAE,CAACuE,WAAW,CAACC,KAAb,EAAoBD,WAAW,CAACE,MAAhC,EAAwCF,WAAW,CAACG,kBAApD,CAD0C;AAEhDjD,IAAAA,GAAG,EAAE,EAAEC,CAAC,EAAE,GAAL,EAAUC,CAAC,EAAE,GAAb,EAAkBC,CAAC,EAAE,GAArB,EAA0BC,CAAC,EAAE,GAA7B,EAF2C,EAAlD;;AAID,CAlDH;;AAoDAkB,CAAC,CAACC,IAAF,CAAO,qCAAP;AACGC,IADH;AAEK;AACL,+CAHA;;AAKGC,kBALH,CAKsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,cAAV,EAA0B,CAAC,CAAD,EAAI,GAAJ,CAA1B,CAL3B;AAMGC,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEjE,YAAF,KAAmBiE,CAAC,CAACC,MAA3B;AACA,QAAMC,UAAU,GAAGnE,YAAY,GAAG,CAAlC;AACA,QAAMV,WAAW,GAAGH,cAAc,CAACN,QAAf,GAA0BM,cAAc,CAAC8G,aAA7D;AACA,QAAMC,SAAS,GAAGjC,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACtC1D,IAAAA,IAAI,EAAEwD,UADgC;AAEtCvD,IAAAA,KAAK,EAAEtB,WAF+B,EAAtB,CAAlB;;;AAKA,QAAM6G,QAAQ,GAAGlC,CAAC,CAAC9D,MAAF,CAASiG,cAAT,CAAwB,EAAEC,IAAI,EAAE,WAAR,EAAqBC,KAAK,EAAE,CAA5B,EAAxB,CAAjB;AACA,QAAM9E,OAAO,GAAGyC,CAAC,CAAC9D,MAAF,CAASsB,oBAAT,EAAhB;AACAD,EAAAA,OAAO,CAAC+E,eAAR,CAAwBJ,QAAxB,EAAkC,CAAlC,EAAqC,CAArC,EAAwCD,SAAxC,EAAmDlG,YAAnD;AACAiE,EAAAA,CAAC,CAACjC,KAAF,CAAQC,MAAR,CAAe,CAACT,OAAO,CAACU,MAAR,EAAD,CAAf;;AAEA,QAAMsE,kBAAkB,GAAG,IAAI9G,UAAJ,CAAeyE,UAAf,CAA3B;AACA,QAAMF,CAAC,CAAC7E,qBAAF,CAAwB8G,SAAxB,EAAmC5G,WAAnC,EAAgDkH,kBAAhD,CAAN;AACD,CAtBH;;AAwBA9C,CAAC,CAACC,IAAF,CAAO,gCAAP;AACGC,IADH;AAEK;AACL,+CAHA;;AAKGC,kBALH,CAKsB,CAAAC,CAAC;AACnBA,CAAC;AACEC,OADH,CACW,cADX,EAC2B,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,EAAR,CAD3B;AAEGA,OAFH,CAEW,iBAFX,EAE8B,CAAC,CAAD,EAAI,CAAJ,CAF9B;AAGGA,OAHH,CAGW,cAHX,EAG2B,CAAC,CAAD,EAAI,CAAJ,CAH3B;AAIGA,OAJH,CAIW,cAJX,EAI2B,CAAC,EAAD,EAAK,EAAL,CAJ3B;AAKG0C,MALH,CAKUxC,CAAC,IAAI;AACX;AACA,SAAO,EAAEA,CAAC,CAACjE,YAAF,KAAmB,CAAnB,IAAwBiE,CAAC,CAAC6B,YAAF,KAAmB,EAA7C,CAAP;AACD,CARH,CANJ;;AAgBG9B,EAhBH,CAgBM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEjE,YAAF,EAAgB0G,eAAhB,EAAiCC,YAAjC,EAA+Cb,YAA/C,KAAgE7B,CAAC,CAACC,MAAxE;AACA,QAAM0C,gBAAgB,GAAG,QAAzB;AACA,QAAM1B,WAAW,GAAG,CAAC,EAAD,EAAK,EAAL,EAASwB,eAAT,CAApB;;AAEA,QAAMG,UAAU,GAAG5C,CAAC,CAAC9D,MAAF,CAASM,aAAT,CAAuB;AACxCC,IAAAA,MAAM,EAAEkG,gBADgC;AAExChG,IAAAA,KAAK,EAAEC,eAAe,CAAChC,QAAhB,GAA2BgC,eAAe,CAACiG,iBAFV;AAGxCnG,IAAAA,IAAI,EAAEuE,WAHkC;AAIxC6B,IAAAA,aAAa,EAAEJ,YAAY,GAAG,CAJU,EAAvB,CAAnB;;;AAOA,QAAMd,WAAW,GAAG,GAApB;AACA,QAAM5E,MAAM,GAAG9C,oBAAoB,CAACyI,gBAAD,EAAmB,IAAnB,EAAyB1B,WAAzB,EAAsC;AACvE8B,IAAAA,QAAQ,EAAEL,YAD6D;AAEvEd,IAAAA,WAFuE;AAGvEC,IAAAA,YAHuE,EAAtC,CAAnC;;;AAMA,QAAMmB,aAAa,GAAGhG,MAAM,CAACwE,UAAP,GAAoByB,IAAI,CAACC,GAAL,CAASnH,YAAT,CAA1C;AACA,QAAMkG,SAAS,GAAGjC,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACtC1D,IAAAA,IAAI,EAAEsG,aADgC;AAEtCrG,IAAAA,KAAK,EAAEzB,cAAc,CAACN,QAAf,GAA0BM,cAAc,CAACR,QAFV,EAAtB,CAAlB;;;AAKA,QAAM6C,OAAO,GAAGyC,CAAC,CAAC9D,MAAF,CAASsB,oBAAT,EAAhB;;AAEA;AACA,OAAK,IAAI2F,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGV,eAA5B,EAA6C,EAAEU,KAA/C,EAAsD;AACpD,UAAMC,UAAU,GAAG7F,OAAO,CAAC8F,eAAR,CAAwB;AACzCC,MAAAA,gBAAgB,EAAE;AAChB;AACEC,QAAAA,IAAI,EAAEX,UAAU,CAACtF,UAAX,CAAsB;AAC1BkG,UAAAA,cAAc,EAAEL,KADU;AAE1BV,UAAAA,eAAe,EAAE,CAFS;AAG1BgB,UAAAA,YAAY,EAAEf,YAHY,EAAtB,CADR;;AAMEgB,QAAAA,SAAS,EAAE,EAAEC,CAAC,EAAER,KAAK,GAAG,CAAb,EAAgB1D,CAAC,EAAE,CAAnB,EAAsBmE,CAAC,EAAE,CAAzB,EAA4BC,CAAC,EAAE,CAA/B,EANb;AAOEC,QAAAA,OAAO,EAAE,OAPX,EADgB,CADuB,EAAxB,CAAnB;;;;AAaAV,IAAAA,UAAU,CAACtF,OAAX;AACD;;AAED;AACA,QAAMqC,aAAa,GAAG8C,IAAI,CAACc,GAAL,CAAShI,YAAT,EAAuB,CAAvB,CAAtB;AACAwB,EAAAA,OAAO,CAACyG,mBAAR;AACE,IAAElC,OAAO,EAAEc,UAAX,EAAuBG,QAAQ,EAAEL,YAAjC,EADF;AAEE,IAAEtH,MAAM,EAAE6G,SAAV,EAAqB5E,MAAM,EAAE8C,aAA7B,EAA4CyB,WAA5C,EAAyDC,YAAzD,EAFF;AAGE7E,EAAAA,MAAM,CAACiH,OAHT;;AAKAjE,EAAAA,CAAC,CAACjC,KAAF,CAAQC,MAAR,CAAe,CAACT,OAAO,CAACU,MAAR,EAAD,CAAf;;AAEA;AACA,QAAM3C,YAAY,GAAG,IAAIG,UAAJ,CAAeuH,aAAf,CAArB;AACA,OAAK,IAAIG,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGV,eAA5B,EAA6C,EAAEU,KAA/C,EAAsD;AACpD,SAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlH,MAAM,CAACiH,OAAP,CAAe,CAAf,CAApB,EAAuC,EAAEC,CAAzC,EAA4C;AAC1C,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnH,MAAM,CAACiH,OAAP,CAAe,CAAf,CAApB,EAAuC,EAAEE,CAAzC,EAA4C;AAC1C7I,QAAAA,YAAY,CAAC6E,aAAa,GAAGgD,KAAK,GAAGvB,WAAR,GAAsBC,YAAtC,GAAqDqC,CAAC,GAAGtC,WAAzD,GAAuEuC,CAAxE,CAAZ;AACEhB,QAAAA,KAAK,GAAG,CADV;AAED;AACF;AACF;AACDnD,EAAAA,CAAC,CAACpE,0BAAF,CAA6BqG,SAA7B,EAAwC3G,YAAxC;AACD,CAjFH;;AAmFAmE,CAAC,CAACC,IAAF,CAAO,gBAAP;AACGC,IADH;AAEK;AACL,mEAHA;;AAKGC,kBALH,CAKsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,cAAV,EAA0B,CAAC,CAAD,EAAI,GAAJ,CAA1B,CAL3B;AAMGC,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEjE,YAAF,KAAmBiE,CAAC,CAACC,MAA3B;;AAEA,QAAMjE,eAAe,GAAG,EAAxB;AACA,QAAMZ,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnC1D,IAAAA,IAAI,EAAEX,YAAY,GAAGC,eADc;AAEnCW,IAAAA,KAAK,EAAEzB,cAAc,CAACN,QAAf,GAA0BM,cAAc,CAACkJ,OAFb,EAAtB,CAAf;;;AAKA,QAAMtI,mBAAmB,GAAGkE,CAAC,CAAC9D,MAAF,CAAS6C,kBAAT,CAA4B;AACtDC,IAAAA,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAd4D,EAA5B,CAA5B;;;AAiBA;AACAgB,EAAAA,CAAC,CAACnE,6BAAF,CAAgCC,mBAAhC,EAAqDV,MAArD,EAA6DW,YAA7D,EAA2EC,eAA3E;AACD,CAlCH;;AAoCAyD,CAAC,CAACC,IAAF,CAAO,yBAAP;AACGC,IADH;AAEK;AACL,8EAHA;;AAKGC,kBALH,CAKsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,cAAV,EAA0B,CAAC,CAAD,EAAI,GAAJ,CAA1B,CAL3B;AAMGC,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEjE,YAAF,KAAmBiE,CAAC,CAACC,MAA3B;AACA,QAAMjE,eAAe,GAAG,EAAxB;AACA,QAAMZ,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnC1D,IAAAA,IAAI,EAAEX,YAAY,GAAGC,eADc;AAEnCW,IAAAA,KAAK,EAAEzB,cAAc,CAACN,QAAf,GAA0BM,cAAc,CAAC2B,OAFb,EAAtB,CAAf;;;AAKA,QAAMf,mBAAmB,GAAGkE,CAAC,CAAC9D,MAAF,CAAS6C,kBAAT,CAA4B;AACtDC,IAAAA,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAd4D,EAA5B,CAA5B;;;AAiBA;AACAgB,EAAAA,CAAC,CAACnE,6BAAF,CAAgCC,mBAAhC,EAAqDV,MAArD,EAA6DW,YAA7D,EAA2EC,eAA3E;AACD,CAjCH;;AAmCAyD,CAAC,CAACC,IAAF,CAAO,gBAAP;AACGC,IADH;AAEK;AACL,8EAHA;;AAKGC,kBALH,CAKsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,cAAV,EAA0B,CAAC,CAAD,EAAI,GAAJ,CAA1B,CAL3B;AAMGC,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEjE,YAAF,KAAmBiE,CAAC,CAACC,MAA3B;AACA,QAAMjE,eAAe,GAAG,EAAxB;AACA,QAAMZ,MAAM,GAAG4E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACnC1D,IAAAA,IAAI,EAAEX,YAAY,GAAGC,eADc;AAEnCW,IAAAA,KAAK,EAAEzB,cAAc,CAACN,QAAf,GAA0BM,cAAc,CAAC2B,OAFb,EAAtB,CAAf;;;AAKA,QAAMf,mBAAmB,GAAGkE,CAAC,CAAC9D,MAAF,CAAS6C,kBAAT,CAA4B;AACtDC,IAAAA,IAAI,EAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAd4D,EAA5B,CAA5B;;;AAiBA;AACAgB,EAAAA,CAAC,CAACnE,6BAAF,CAAgCC,mBAAhC,EAAqDV,MAArD,EAA6DW,YAA7D,EAA2EC,eAA3E;AACD,CAjCH;;AAmCAyD,CAAC,CAACC,IAAF,CAAO,eAAP;AACGC,IADH;AAEK;AACL,4EAHA;;AAKGC,kBALH,CAKsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,cAAV,EAA0B,CAAC,CAAD,EAAI,EAAJ,CAA1B,CAL3B;AAMGC,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEjE,YAAF,KAAmBiE,CAAC,CAACC,MAA3B;;AAEA,QAAMoE,cAAc,GAAGrE,CAAC,CAACvB,mDAAF;AACrBuB,EAAAA,CAAC,CAAC9D,MAAF,CAAS6C,kBAAT,CAA4B;AAC1BC,IAAAA,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAhBkC,EAA5B,CADqB;;AAmBrB,MAnBqB,CAAvB;;;AAsBA,QAAMkB,UAAU,GAAG,KAAKnE,YAAxB;AACA,QAAMuI,YAAY,GAAGtE,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACzC1D,IAAAA,IAAI,EAAEwD,UADmC;AAEzCvD,IAAAA,KAAK,EAAEzB,cAAc,CAACqJ,MAAf,GAAwBrJ,cAAc,CAACN,QAFL,EAAtB,CAArB;;;AAKA,QAAM2B,aAAa,GAAGyD,CAAC,CAAC9D,MAAF,CAASM,aAAT,CAAuB;AAC3CC,IAAAA,MAAM,EAAE,YADmC;AAE3CC,IAAAA,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAFqC;AAG3CC,IAAAA,KAAK,EAAEC,eAAe,CAAChC,QAAhB,GAA2BgC,eAAe,CAACiG,iBAHP,EAAvB,CAAtB;;;AAMA,QAAMtF,OAAO,GAAGyC,CAAC,CAAC9D,MAAF,CAASsB,oBAAT,EAAhB;AACA,QAAM4F,UAAU,GAAG7F,OAAO,CAAC8F,eAAR,CAAwB;AACzCC,IAAAA,gBAAgB,EAAE;AAChB;AACEC,MAAAA,IAAI,EAAEhH,aAAa,CAACe,UAAd,EADR;AAEEoG,MAAAA,SAAS,EAAE,EAAEC,CAAC,EAAE,GAAL,EAAUlE,CAAC,EAAE,GAAb,EAAkBmE,CAAC,EAAE,GAArB,EAA0BC,CAAC,EAAE,GAA7B,EAFb;AAGEC,MAAAA,OAAO,EAAE,OAHX,EADgB,CADuB,EAAxB,CAAnB;;;;AASAV,EAAAA,UAAU,CAACoB,eAAX,CAA2B,CAA3B,EAA8BF,YAA9B,EAA4CvI,YAA5C;AACAqH,EAAAA,UAAU,CAACxF,WAAX,CAAuByG,cAAvB;AACAjB,EAAAA,UAAU,CAACqB,IAAX,CAAgB,CAAhB;AACArB,EAAAA,UAAU,CAACtF,OAAX;AACAkC,EAAAA,CAAC,CAACjC,KAAF,CAAQC,MAAR,CAAe,CAACT,OAAO,CAACU,MAAR,EAAD,CAAf;;AAEA+B,EAAAA,CAAC,CAAC9B,iBAAF,CAAoB3B,aAApB,EAAmC,YAAnC,EAAiD;AAC/CG,IAAAA,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADyC;AAE/CyB,IAAAA,GAAG,EAAE,EAAEC,CAAC,EAAE,GAAL,EAAUC,CAAC,EAAE,GAAb,EAAkBC,CAAC,EAAE,GAArB,EAA0BC,CAAC,EAAE,GAA7B,EAF0C,EAAjD;;;AAKA,QAAMgE,kBAAkB,GAAG,IAAI9G,UAAJ,CAAeyE,UAAf,CAA3B;AACAF,EAAAA,CAAC,CAACpE,0BAAF,CAA6B0I,YAA7B,EAA2C/B,kBAA3C;AACD,CAlEH;;AAoEA9C,CAAC,CAACC,IAAF,CAAO,cAAP;AACGC,IADH;AAEK;AACL,0EAHA;;AAKGC,kBALH,CAKsBC,CAAC,IAAIA,CAAC,CAACC,OAAF,CAAU,cAAV,EAA0B,CAAC,CAAD,EAAI,EAAJ,CAA1B,CAL3B;AAMGC,EANH,CAMM,MAAMC,CAAN,IAAW;AACb,QAAM,EAAEjE,YAAF,KAAmBiE,CAAC,CAACC,MAA3B;;AAEA,QAAMoE,cAAc,GAAGrE,CAAC,CAACvB,mDAAF;AACrBuB,EAAAA,CAAC,CAAC9D,MAAF,CAAS6C,kBAAT,CAA4B;AAC1BC,IAAAA,IAAI,EAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAjBkC,EAA5B,CADqB;;AAoBrB,OApBqB,CAAvB;;;AAuBA;AACA,QAAMkB,UAAU,GAAG,IAAInE,YAAvB;AACA,QAAM2I,WAAW,GAAG1E,CAAC,CAAC9D,MAAF,CAASkE,YAAT,CAAsB;AACxC1D,IAAAA,IAAI,EAAEwD,UADkC;AAExCvD,IAAAA,KAAK,EAAEzB,cAAc,CAACyJ,KAAf,GAAuBzJ,cAAc,CAACN,QAFL,EAAtB,CAApB;;;AAKA,QAAM2B,aAAa,GAAGyD,CAAC,CAAC9D,MAAF,CAASM,aAAT,CAAuB;AAC3CC,IAAAA,MAAM,EAAE,YADmC;AAE3CC,IAAAA,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAFqC;AAG3CC,IAAAA,KAAK,EAAEC,eAAe,CAAChC,QAAhB,GAA2BgC,eAAe,CAACiG,iBAHP,EAAvB,CAAtB;;;AAMA,QAAMtF,OAAO,GAAGyC,CAAC,CAAC9D,MAAF,CAASsB,oBAAT,EAAhB;AACA,QAAM4F,UAAU,GAAG7F,OAAO,CAAC8F,eAAR,CAAwB;AACzCC,IAAAA,gBAAgB,EAAE;AAChB;AACEC,MAAAA,IAAI,EAAEhH,aAAa,CAACe,UAAd,EADR;AAEEoG,MAAAA,SAAS,EAAE,EAAEC,CAAC,EAAE,GAAL,EAAUlE,CAAC,EAAE,GAAb,EAAkBmE,CAAC,EAAE,GAArB,EAA0BC,CAAC,EAAE,GAA7B,EAFb;AAGEC,MAAAA,OAAO,EAAE,OAHX,EADgB,CADuB,EAAxB,CAAnB;;;;AASAV,EAAAA,UAAU,CAACxF,WAAX,CAAuByG,cAAvB;AACAjB,EAAAA,UAAU,CAACwB,cAAX,CAA0BF,WAA1B,EAAuC,QAAvC,EAAiD3I,YAAjD,EAA+D,CAA/D;AACAqH,EAAAA,UAAU,CAACyB,WAAX,CAAuB,CAAvB;AACAzB,EAAAA,UAAU,CAACtF,OAAX;AACAkC,EAAAA,CAAC,CAACjC,KAAF,CAAQC,MAAR,CAAe,CAACT,OAAO,CAACU,MAAR,EAAD,CAAf;;AAEA+B,EAAAA,CAAC,CAAC9B,iBAAF,CAAoB3B,aAApB,EAAmC,YAAnC,EAAiD;AAC/CG,IAAAA,IAAI,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADyC;AAE/CyB,IAAAA,GAAG,EAAE,EAAEC,CAAC,EAAE,GAAL,EAAUC,CAAC,EAAE,GAAb,EAAkBC,CAAC,EAAE,GAArB,EAA0BC,CAAC,EAAE,GAA7B,EAF0C,EAAjD;;;AAKA,QAAMgE,kBAAkB,GAAG,IAAI9G,UAAJ,CAAeyE,UAAf,CAA3B;AACAF,EAAAA,CAAC,CAACpE,0BAAF,CAA6B8I,WAA7B,EAA0CnC,kBAA1C;AACD,CApEH","sourcesContent":["import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { GPUConst } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { checkElementsEqual } from '../../../util/check_contents.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\n\nexport const description = `\nTest uninitialized buffers are initialized to zero when read\n(or read-written, e.g. with depth write or atomics).\n\nNote that:\n-  We don't need 'copy_buffer_to_buffer_copy_destination' here because there has already been an\n   operation test 'command_buffer.copyBufferToBuffer.single' that provides the same functionality.\n\nTODO:\nTest the buffers whose first usage is being used:\n- as indirect buffer\n`;\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kBufferUsagesForMappedAtCreationTests = [\n  GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ,\n  GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.MAP_WRITE,\n  GPUConst.BufferUsage.COPY_SRC,\n];\n\nclass F extends GPUTest {\n  GetBufferUsageFromMapMode(mapMode: GPUMapModeFlags): number {\n    switch (mapMode) {\n      case GPUMapMode.READ:\n        return GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      case GPUMapMode.WRITE:\n        return GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      default:\n        unreachable();\n        return 0;\n    }\n  }\n\n  async CheckGPUBufferContent(\n    buffer: GPUBuffer,\n    bufferUsage: GPUBufferUsageFlags,\n    expectedData: Uint8Array\n  ): Promise<void> {\n    // We can only check the buffer contents with t.expectGPUBufferValuesEqual() when the buffer\n    // usage contains COPY_SRC.\n    if (bufferUsage & GPUBufferUsage.MAP_READ) {\n      await buffer.mapAsync(GPUMapMode.READ);\n      this.expectOK(checkElementsEqual(new Uint8Array(buffer.getMappedRange()), expectedData));\n      buffer.unmap();\n    } else {\n      assert((bufferUsage & GPUBufferUsage.COPY_SRC) !== 0);\n      this.expectGPUBufferValuesEqual(buffer, expectedData);\n    }\n  }\n\n  TestBufferZeroInitInBindGroup(\n    computeShaderModule: GPUShaderModule,\n    buffer: GPUBuffer,\n    bufferOffset: number,\n    boundBufferSize: number\n  ): void {\n    const computePipeline = this.device.createComputePipeline({\n      compute: {\n        module: computeShaderModule,\n        entryPoint: 'main',\n      },\n    });\n    const outputTexture = this.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE,\n    });\n    const bindGroup = this.device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer,\n            offset: bufferOffset,\n            size: boundBufferSize,\n          },\n        },\n        {\n          binding: 1,\n          resource: outputTexture.createView(),\n        },\n      ],\n    });\n\n    const encoder = this.device.createCommandEncoder();\n    const computePass = encoder.beginComputePass();\n    computePass.setBindGroup(0, bindGroup);\n    computePass.setPipeline(computePipeline);\n    computePass.dispatch(1);\n    computePass.endPass();\n    this.queue.submit([encoder.finish()]);\n\n    this.expectSingleColor(outputTexture, 'rgba8unorm', {\n      size: [1, 1, 1],\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n\n    // Verify the remaining part of the buffer is also cleared to 0.\n    if (bufferOffset > 0) {\n      const expectedBufferdata = new Uint8Array(boundBufferSize + bufferOffset);\n      this.expectGPUBufferValuesEqual(buffer, expectedBufferdata);\n    }\n  }\n\n  CreateRenderPipelineForVertexAndIndexBufferInitTest(\n    vertexShaderModule: GPUShaderModule,\n    testVertexBuffer: boolean\n  ): GPURenderPipeline {\n    const renderPipelineDescriptor: GPURenderPipelineDescriptor = {\n      vertex: {\n        module: vertexShaderModule,\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n        [[stage(fragment)]]\n        fn main([[location(0)]] i_color : vec4<f32>) -> [[location(0)]] vec4<f32> {\n            return i_color;\n        }`,\n        }),\n        entryPoint: 'main',\n        targets: [{ format: 'rgba8unorm' }],\n      },\n      primitive: {\n        topology: 'point-list',\n      },\n    };\n    if (testVertexBuffer) {\n      renderPipelineDescriptor.vertex.buffers = [\n        {\n          arrayStride: 16,\n          attributes: [{ format: 'float32x4', offset: 0, shaderLocation: 0 }],\n        },\n      ];\n    }\n\n    return this.device.createRenderPipeline(renderPipelineDescriptor);\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('partial_write_buffer')\n  .desc(\n    `Verify when we upload data to a part of a buffer with writeBuffer() just after the creation of\nthe buffer, the remaining part of that buffer will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('offset', [0, 8, -12]))\n  .fn(async t => {\n    const { offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const copySize = 12;\n    const writeData = new Uint8Array(copySize);\n    const expectedData = new Uint8Array(bufferSize);\n    for (let i = 0; i < copySize; ++i) {\n      expectedData[appliedOffset + i] = writeData[i] = i + 1;\n    }\n    t.queue.writeBuffer(buffer, appliedOffset, writeData, 0);\n\n    t.expectGPUBufferValuesEqual(buffer, expectedData);\n  });\n\ng.test('map_whole_buffer')\n  .desc(\n    `Verify when we map the whole range of a mappable GPUBuffer to a typed array buffer just after\ncreating the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer itself\nhave already been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const bufferSize = 32;\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    await buffer.mapAsync(mapMode);\n    const readData = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(readData[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('map_partial_buffer')\n  .desc(\n    `Verify when we map a subrange of a mappable GPUBuffer to a typed array buffer just after the\ncreation of the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer have\nalready been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions).beginSubcases().combine('offset', [0, 8, -16]))\n  .fn(async t => {\n    const { mapMode, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mapSize = 16;\n      await buffer.mapAsync(mapMode, appliedOffset, mapSize);\n      const mappedData = new Uint8Array(buffer.getMappedRange(appliedOffset, mapSize));\n      for (let i = 0; i < mapSize; ++i) {\n        t.expect(mappedData[i] === 0);\n        if (mapMode === GPUMapMode.WRITE) {\n          mappedData[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_whole_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at the whole range of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u => u.combine('bufferUsage', kBufferUsagesForMappedAtCreationTests))\n  .fn(async t => {\n    const { bufferUsage } = t.params;\n\n    const bufferSize = 32;\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const mapped = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(mapped[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_partial_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at a subrange of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u =>\n    u\n      .combine('bufferUsage', kBufferUsagesForMappedAtCreationTests)\n      .beginSubcases()\n      .combine('offset', [0, 8, -16])\n  )\n  .fn(async t => {\n    const { bufferUsage, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mappedSize = 12;\n      const mapped = new Uint8Array(buffer.getMappedRange(appliedOffset, mappedSize));\n      for (let i = 0; i < mappedSize; ++i) {\n        t.expect(mapped[i] === 0);\n        if (!(bufferUsage & GPUBufferUsage.MAP_READ)) {\n          mapped[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_buffer_copy_source')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToBuffer(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .fn(async t => {\n    const bufferSize = 32;\n    const bufferUsage = GPUBufferUsage.COPY_SRC;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    // copyBufferToBuffer() is called inside t.CheckGPUBufferContent().\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_texture')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToTexture(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 8]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const textureSize = { width: 8, height: 8, depthOrArrayLayers: 1 };\n    const dstTextureFormat = 'rgba8unorm';\n\n    const dstTexture = t.device.createTexture({\n      size: textureSize,\n      format: dstTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    const layout = getTextureCopyLayout(dstTextureFormat, '2d', [\n      textureSize.width,\n      textureSize.height,\n      textureSize.depthOrArrayLayers,\n    ]);\n    const srcBufferSize = layout.byteLength + bufferOffset;\n    const srcBufferUsage = GPUBufferUsage.COPY_SRC;\n    const srcBuffer = t.device.createBuffer({\n      size: srcBufferSize,\n      usage: srcBufferUsage,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyBufferToTexture(\n      {\n        buffer: srcBuffer,\n        offset: bufferOffset,\n        bytesPerRow: layout.bytesPerRow,\n        rowsPerImage: layout.rowsPerImage,\n      },\n      { texture: dstTexture },\n      textureSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Verify the contents in srcBuffer are all 0.\n    const expectedSrcBufferData = new Uint8Array(srcBufferSize);\n    await t.CheckGPUBufferContent(srcBuffer, srcBufferUsage, expectedSrcBufferData);\n\n    // Verify the texels in dstTexture are all 0.\n    t.expectSingleColor(dstTexture, dstTextureFormat, {\n      size: [textureSize.width, textureSize.height, textureSize.depthOrArrayLayers],\n      exp: { R: 0.0, G: 0.0, B: 0.0, A: 0.0 },\n    });\n  });\n\ng.test('resolve_query_set_to_partial_buffer')\n  .desc(\n    `Verify when we resolve a query set into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const bufferSize = bufferOffset + 8;\n    const bufferUsage = GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE;\n    const dstBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const querySet = t.device.createQuerySet({ type: 'occlusion', count: 1 });\n    const encoder = t.device.createCommandEncoder();\n    encoder.resolveQuerySet(querySet, 0, 1, dstBuffer, bufferOffset);\n    t.queue.submit([encoder.finish()]);\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(dstBuffer, bufferUsage, expectedBufferData);\n  });\n\ng.test('copy_texture_to_partial_buffer')\n  .desc(\n    `Verify when we copy from a GPUTexture into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u =>\n    u\n      .combine('bufferOffset', [0, 8, -16])\n      .combine('arrayLayerCount', [1, 3])\n      .combine('copyMipLevel', [0, 2])\n      .combine('rowsPerImage', [16, 20])\n      .filter(t => {\n        // We don't need to test the copies that will cover the whole GPUBuffer.\n        return !(t.bufferOffset === 0 && t.rowsPerImage === 16);\n      })\n  )\n  .fn(async t => {\n    const { bufferOffset, arrayLayerCount, copyMipLevel, rowsPerImage } = t.params;\n    const srcTextureFormat = 'r8uint';\n    const textureSize = [32, 16, arrayLayerCount] as const;\n\n    const srcTexture = t.device.createTexture({\n      format: srcTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n      size: textureSize,\n      mipLevelCount: copyMipLevel + 1,\n    });\n\n    const bytesPerRow = 256;\n    const layout = getTextureCopyLayout(srcTextureFormat, '2d', textureSize, {\n      mipLevel: copyMipLevel,\n      bytesPerRow,\n      rowsPerImage,\n    });\n\n    const dstBufferSize = layout.byteLength + Math.abs(bufferOffset);\n    const dstBuffer = t.device.createBuffer({\n      size: dstBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n\n    // Initialize srcTexture\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      const renderPass = encoder.beginRenderPass({\n        colorAttachments: [\n          {\n            view: srcTexture.createView({\n              baseArrayLayer: layer,\n              arrayLayerCount: 1,\n              baseMipLevel: copyMipLevel,\n            }),\n            loadValue: { r: layer + 1, g: 0, b: 0, a: 0 },\n            storeOp: 'store',\n          },\n        ],\n      });\n      renderPass.endPass();\n    }\n\n    // Do texture-to-buffer copy\n    const appliedOffset = Math.max(bufferOffset, 0);\n    encoder.copyTextureToBuffer(\n      { texture: srcTexture, mipLevel: copyMipLevel },\n      { buffer: dstBuffer, offset: appliedOffset, bytesPerRow, rowsPerImage },\n      layout.mipSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Check if the contents of the destination bufer are what we expect.\n    const expectedData = new Uint8Array(dstBufferSize);\n    for (let layer = 0; layer < arrayLayerCount; ++layer) {\n      for (let y = 0; y < layout.mipSize[1]; ++y) {\n        for (let x = 0; x < layout.mipSize[0]; ++x) {\n          expectedData[appliedOffset + layer * bytesPerRow * rowsPerImage + y * bytesPerRow + x] =\n            layer + 1;\n        }\n      }\n    }\n    t.expectGPUBufferValuesEqual(dstBuffer, expectedData);\n  });\n\ng.test('uniform_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a uniform buffer just after the creation of that GPUBuffer,\n    all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.UNIFORM,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n  [[block]] struct UBO {\n      value : vec4<u32>;\n  };\n  [[group(0), binding(0)]] var<uniform> ubo : UBO;\n  [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n  [[stage(compute), workgroup_size(1)]] fn main() {\n      if (all(ubo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n      } else {\n          textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n      }\n  }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('readonly_storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a read-only storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    [[block]] struct SSBO {\n        value : vec4<u32>;\n    };\n    [[group(0), binding(0)]] var<storage, read> ssbo : SSBO;\n    [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    [[stage(compute), workgroup_size(1)]] fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('storage_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a storage buffer just after the creation of that\n    GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const boundBufferSize = 16;\n    const buffer = t.device.createBuffer({\n      size: bufferOffset + boundBufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,\n    });\n\n    const computeShaderModule = t.device.createShaderModule({\n      code: `\n    [[block]] struct SSBO {\n        value : vec4<u32>;\n    };\n    [[group(0), binding(0)]] var<storage, read_write> ssbo : SSBO;\n    [[group(0), binding(1)]] var outImage : texture_storage_2d<rgba8unorm, write>;\n\n    [[stage(compute), workgroup_size(1)]] fn main() {\n        if (all(ssbo.value == vec4<u32>(0u, 0u, 0u, 0u))) {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(0.0, 1.0, 0.0, 1.0));\n        } else {\n            textureStore(outImage, vec2<i32>(0, 0), vec4<f32>(1.0, 0.0, 0.0, 1.0));\n        }\n    }`,\n    });\n\n    // Verify the whole range of the buffer has been initialized to 0 in a compute shader.\n    t.TestBufferZeroInitInBindGroup(computeShaderModule, buffer, bufferOffset, boundBufferSize);\n  });\n\ng.test('vertex_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as a vertex buffer just after the creation of that\n  GPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForVertexAndIndexBufferInitTest(\n      t.device.createShaderModule({\n        code: `\n      struct VertexOut {\n        [[location(0)]] color : vec4<f32>;\n        [[builtin(position)]] position : vec4<f32>;\n      };\n\n      [[stage(vertex)]] fn main([[location(0)]] pos : vec4<f32>) -> VertexOut {\n        var output : VertexOut;\n        if (all(pos == vec4<f32>(0.0, 0.0, 0.0, 0.0))) {\n          output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        } else {\n          output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n        }\n        output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        return output;\n      }`,\n      }),\n      true\n    );\n\n    const bufferSize = 16 + bufferOffset;\n    const vertexBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setVertexBuffer(0, vertexBuffer, bufferOffset);\n    renderPass.setPipeline(renderPipeline);\n    renderPass.draw(1);\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    t.expectSingleColor(outputTexture, 'rgba8unorm', {\n      size: [1, 1, 1],\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    t.expectGPUBufferValuesEqual(vertexBuffer, expectedBufferData);\n  });\n\ng.test('index_buffer')\n  .desc(\n    `Verify when we use a GPUBuffer as an index buffer just after the creation of that\nGPUBuffer, all the contents in that GPUBuffer have been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 16]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n\n    const renderPipeline = t.CreateRenderPipelineForVertexAndIndexBufferInitTest(\n      t.device.createShaderModule({\n        code: `\n    struct VertexOut {\n      [[location(0)]] color : vec4<f32>;\n      [[builtin(position)]] position : vec4<f32>;\n    };\n\n    [[stage(vertex)]]\n    fn main([[builtin(vertex_index)]] VertexIndex : u32) -> VertexOut {\n      var output : VertexOut;\n      if (VertexIndex == 0u) {\n        output.color = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n      } else {\n        output.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n      }\n      output.position = vec4<f32>(0.0, 0.0, 0.0, 1.0);\n      return output;\n    }`,\n      }),\n      false\n    );\n\n    // The size of GPUBuffer must be at least 4.\n    const bufferSize = 4 + bufferOffset;\n    const indexBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC,\n    });\n\n    const outputTexture = t.device.createTexture({\n      format: 'rgba8unorm',\n      size: [1, 1, 1],\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: outputTexture.createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 },\n          storeOp: 'store',\n        },\n      ],\n    });\n    renderPass.setPipeline(renderPipeline);\n    renderPass.setIndexBuffer(indexBuffer, 'uint16', bufferOffset, 4);\n    renderPass.drawIndexed(1);\n    renderPass.endPass();\n    t.queue.submit([encoder.finish()]);\n\n    t.expectSingleColor(outputTexture, 'rgba8unorm', {\n      size: [1, 1, 1],\n      exp: { R: 0.0, G: 1.0, B: 0.0, A: 1.0 },\n    });\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    t.expectGPUBufferValuesEqual(indexBuffer, expectedBufferData);\n  });\n"],"file":"buffer.spec.js"}