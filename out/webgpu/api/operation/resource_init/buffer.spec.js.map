{"version":3,"sources":["../../../../../src/webgpu/api/operation/resource_init/buffer.spec.ts"],"names":["makeTestGroup","assert","unreachable","GPUConst","GPUTest","getTextureCopyLayout","description","kMapModeOptions","MapMode","READ","WRITE","kBufferUsagesForMappedAtCreationTests","BufferUsage","COPY_DST","MAP_READ","COPY_SRC","MAP_WRITE","F","GetBufferUsageFromMapMode","mapMode","GPUMapMode","GPUBufferUsage","CheckGPUBufferContent","buffer","bufferUsage","expectedData","mapAsync","expectBuffer","Uint8Array","getMappedRange","unmap","expectGPUBufferValuesEqual","g","test","desc","paramsSubcasesOnly","u","combine","fn","t","offset","params","bufferSize","appliedOffset","device","createBuffer","size","usage","copySize","writeData","i","queue","writeBuffer","readData","expect","beginSubcases","mapSize","mappedData","mappedAtCreation","mapped","mappedSize","bufferOffset","textureSize","width","height","depthOrArrayLayers","dstTextureFormat","dstTexture","createTexture","format","GPUTextureUsage","layout","srcBufferSize","byteLength","srcBufferUsage","srcBuffer","encoder","createCommandEncoder","copyBufferToTexture","bytesPerRow","rowsPerImage","texture","submit","finish","expectedSrcBufferData","expectSingleColor","exp","R","G","B","A","QUERY_RESOLVE","dstBuffer","querySet","createQuerySet","type","count","resolveQuerySet","expectedBufferData"],"mappings":"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","sourcesContent":["import { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { assert, unreachable } from '../../../../common/util/util.js';\nimport { GPUConst } from '../../../constants.js';\nimport { GPUTest } from '../../../gpu_test.js';\nimport { getTextureCopyLayout } from '../../../util/texture/layout.js';\n\nexport const description = `\nTest uninitialized buffers are initialized to zero when read\n(or read-written, e.g. with depth write or atomics).\n\nNote that:\n-  We don't need 'copy_buffer_to_buffer_copy_destination' here because there has already been an\n   operation test 'command_buffer.copyBufferToBuffer.single' that provides the same functionality.\n\nTODO:\nTest the buffers whose first usage is being used:\n- as copy destination in a partial copy\n- as uniform / read-only storage / storage buffer\n- as vertex / index buffer\n- as indirect buffer\n`;\n\nconst kMapModeOptions = [GPUConst.MapMode.READ, GPUConst.MapMode.WRITE];\nconst kBufferUsagesForMappedAtCreationTests = [\n  GPUConst.BufferUsage.COPY_DST | GPUConst.BufferUsage.MAP_READ,\n  GPUConst.BufferUsage.COPY_SRC | GPUConst.BufferUsage.MAP_WRITE,\n  GPUConst.BufferUsage.COPY_SRC,\n];\n\nclass F extends GPUTest {\n  GetBufferUsageFromMapMode(mapMode: GPUMapModeFlags): number {\n    switch (mapMode) {\n      case GPUMapMode.READ:\n        return GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      case GPUMapMode.WRITE:\n        return GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      default:\n        unreachable();\n        return 0;\n    }\n  }\n\n  async CheckGPUBufferContent(\n    buffer: GPUBuffer,\n    bufferUsage: GPUBufferUsageFlags,\n    expectedData: Uint8Array\n  ): Promise<void> {\n    // We can only check the buffer contents with t.expectGPUBufferValuesEqual() when the buffer\n    // usage contains COPY_SRC.\n    if (bufferUsage & GPUBufferUsage.MAP_READ) {\n      await buffer.mapAsync(GPUMapMode.READ);\n      this.expectBuffer(new Uint8Array(buffer.getMappedRange()), expectedData);\n      buffer.unmap();\n    } else {\n      assert((bufferUsage & GPUBufferUsage.COPY_SRC) !== 0);\n      this.expectGPUBufferValuesEqual(buffer, expectedData);\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('partial_write_buffer')\n  .desc(\n    `Verify when we upload data to a part of a buffer with writeBuffer() just after the creation of\nthe buffer, the remaining part of that buffer will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('offset', [0, 8, -12]))\n  .fn(async t => {\n    const { offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const copySize = 12;\n    const writeData = new Uint8Array(copySize);\n    const expectedData = new Uint8Array(bufferSize);\n    for (let i = 0; i < copySize; ++i) {\n      expectedData[appliedOffset + i] = writeData[i] = i + 1;\n    }\n    t.queue.writeBuffer(buffer, appliedOffset, writeData, 0);\n\n    t.expectGPUBufferValuesEqual(buffer, expectedData);\n  });\n\ng.test('map_whole_buffer')\n  .desc(\n    `Verify when we map the whole range of a mappable GPUBuffer to a typed array buffer just after\ncreating the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer itself\nhave already been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions))\n  .fn(async t => {\n    const { mapMode } = t.params;\n\n    const bufferSize = 32;\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    await buffer.mapAsync(mapMode);\n    const readData = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(readData[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('map_partial_buffer')\n  .desc(\n    `Verify when we map a subrange of a mappable GPUBuffer to a typed array buffer just after the\ncreation of the GPUBuffer, the contents of both the typed array buffer and the GPUBuffer have\nalready been initialized to 0.`\n  )\n  .params(u => u.combine('mapMode', kMapModeOptions).beginSubcases().combine('offset', [0, 8, -16]))\n  .fn(async t => {\n    const { mapMode, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const bufferUsage = t.GetBufferUsageFromMapMode(mapMode);\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mapSize = 16;\n      await buffer.mapAsync(mapMode, appliedOffset, mapSize);\n      const mappedData = new Uint8Array(buffer.getMappedRange(appliedOffset, mapSize));\n      for (let i = 0; i < mapSize; ++i) {\n        t.expect(mappedData[i] === 0);\n        if (mapMode === GPUMapMode.WRITE) {\n          mappedData[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_whole_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at the whole range of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u => u.combine('bufferUsage', kBufferUsagesForMappedAtCreationTests))\n  .fn(async t => {\n    const { bufferUsage } = t.params;\n\n    const bufferSize = 32;\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const mapped = new Uint8Array(buffer.getMappedRange());\n    for (let i = 0; i < bufferSize; ++i) {\n      t.expect(mapped[i] === 0);\n    }\n    buffer.unmap();\n\n    const expectedData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('mapped_at_creation_partial_buffer')\n  .desc(\n    `Verify when we call getMappedRange() at a subrange of a GPUBuffer created with\nmappedAtCreation === true just after its creation, the contents of both the returned typed\narray buffer of getMappedRange() and the GPUBuffer itself have all been initialized to 0.`\n  )\n  .params(u =>\n    u\n      .combine('bufferUsage', kBufferUsagesForMappedAtCreationTests)\n      .beginSubcases()\n      .combine('offset', [0, 8, -16])\n  )\n  .fn(async t => {\n    const { bufferUsage, offset } = t.params;\n    const bufferSize = 32;\n    const appliedOffset = offset >= 0 ? offset : bufferSize + offset;\n\n    const buffer = t.device.createBuffer({\n      mappedAtCreation: true,\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    {\n      const mappedSize = 12;\n      const mapped = new Uint8Array(buffer.getMappedRange(appliedOffset, mappedSize));\n      for (let i = 0; i < mappedSize; ++i) {\n        t.expect(mapped[i] === 0);\n        if (!(bufferUsage & GPUBufferUsage.MAP_READ)) {\n          mapped[i] = expectedData[appliedOffset + i] = i + 1;\n        }\n      }\n      buffer.unmap();\n    }\n\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_buffer_copy_source')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToBuffer(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .fn(async t => {\n    const bufferSize = 32;\n    const bufferUsage = GPUBufferUsage.COPY_SRC;\n    const buffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const expectedData = new Uint8Array(bufferSize);\n    // copyBufferToBuffer() is called inside t.CheckGPUBufferContent().\n    await t.CheckGPUBufferContent(buffer, bufferUsage, expectedData);\n  });\n\ng.test('copy_buffer_to_texture')\n  .desc(\n    `Verify when the first usage of a GPUBuffer is being used as the source buffer of\nCopyBufferToTexture(), the contents of the GPUBuffer have already been initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 8]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const textureSize = { width: 8, height: 8, depthOrArrayLayers: 1 };\n    const dstTextureFormat = 'rgba8unorm';\n\n    const dstTexture = t.device.createTexture({\n      size: textureSize,\n      format: dstTextureFormat,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n    const layout = getTextureCopyLayout(dstTextureFormat, '2d', [\n      textureSize.width,\n      textureSize.height,\n      textureSize.depthOrArrayLayers,\n    ]);\n    const srcBufferSize = layout.byteLength + bufferOffset;\n    const srcBufferUsage = GPUBufferUsage.COPY_SRC;\n    const srcBuffer = t.device.createBuffer({\n      size: srcBufferSize,\n      usage: srcBufferUsage,\n    });\n\n    const encoder = t.device.createCommandEncoder();\n    encoder.copyBufferToTexture(\n      {\n        buffer: srcBuffer,\n        offset: bufferOffset,\n        bytesPerRow: layout.bytesPerRow,\n        rowsPerImage: layout.rowsPerImage,\n      },\n      { texture: dstTexture },\n      textureSize\n    );\n    t.queue.submit([encoder.finish()]);\n\n    // Verify the contents in srcBuffer are all 0.\n    const expectedSrcBufferData = new Uint8Array(srcBufferSize);\n    await t.CheckGPUBufferContent(srcBuffer, srcBufferUsage, expectedSrcBufferData);\n\n    // Verify the texels in dstTexture are all 0.\n    t.expectSingleColor(dstTexture, dstTextureFormat, {\n      size: [textureSize.width, textureSize.height, textureSize.depthOrArrayLayers],\n      exp: { R: 0.0, G: 0.0, B: 0.0, A: 0.0 },\n    });\n  });\n\ng.test('resolve_query_set_to_partial_buffer')\n  .desc(\n    `Verify when we resolve a query set into a GPUBuffer just after creating that GPUBuffer, the\nremaining part of it will be initialized to 0.`\n  )\n  .paramsSubcasesOnly(u => u.combine('bufferOffset', [0, 256]))\n  .fn(async t => {\n    const { bufferOffset } = t.params;\n    const bufferSize = bufferOffset + 8;\n    const bufferUsage = GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE;\n    const dstBuffer = t.device.createBuffer({\n      size: bufferSize,\n      usage: bufferUsage,\n    });\n\n    const querySet = t.device.createQuerySet({ type: 'occlusion', count: 1 });\n    const encoder = t.device.createCommandEncoder();\n    encoder.resolveQuerySet(querySet, 0, 1, dstBuffer, bufferOffset);\n    t.queue.submit([encoder.finish()]);\n\n    const expectedBufferData = new Uint8Array(bufferSize);\n    await t.CheckGPUBufferContent(dstBuffer, bufferUsage, expectedBufferData);\n  });\n"],"file":"buffer.spec.js"}