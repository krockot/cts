{"version":3,"sources":["../../../../src/webgpu/api/validation/createRenderPipeline.spec.ts"],"names":["description","makeTestGroup","kTextureFormats","kTextureFormatInfo","ValidationTest","F","getDescriptor","options","defaultTargets","format","topology","targets","sampleCount","depthStencil","length","fragColorType","suffix","endsWith","vertex","module","device","createShaderModule","code","entryPoint","fragment","layout","getPipelineLayout","primitive","multisample","count","createPipelineLayout","bindGroupLayouts","createTexture","params","size","width","height","depthOrArrayLayers","usage","GPUTextureUsage","RENDER_ATTACHMENT","g","test","fn","t","descriptor","createRenderPipeline","goodDescriptor","badDescriptor","expectValidationError","u","combine","info","selectDeviceOrSkipTestCase","feature","renderable","color","paramsSimple","_success","attachmentSamples","pipelineSamples","colorTexture","depthStencilTexture","renderPassDescriptorWithoutDepthStencil","colorAttachments","view","createView","loadValue","r","b","a","storeOp","renderPassDescriptorWithDepthStencilOnly","depthStencilAttachment","depthLoadValue","depthStoreOp","stencilLoadValue","stencilStoreOp","pipelineWithoutDepthStencil","pipelineWithDepthStencilOnly","renderPassDescriptor","pipeline","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","setPipeline","endPass","finish"],"mappings":"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","sourcesContent":["export const description = `\ncreateRenderPipeline validation tests.\n\nTODO: review existing tests, write descriptions, and make sure tests are complete.\n      Make sure the following is covered. Consider splitting the file if too large/disjointed.\n> - various attachment problems\n>\n> - interface matching between vertex and fragment shader\n>     - superset, subset, etc.\n>\n> - vertex stage {valid, invalid}\n> - fragment stage {valid, invalid}\n> - primitive topology all possible values\n> - rasterizationState various values\n> - multisample count {0, 1, 3, 4, 8, 16, 1024}\n> - multisample mask {0, 0xFFFFFFFF}\n> - alphaToCoverage:\n>     - alphaToCoverageEnabled is { true, false } and sampleCount { = 1, = 4 }.\n>       The only failing case is (true, 1).\n>     - output SV_Coverage semantics is statically used by fragmentStage and\n>       alphaToCoverageEnabled is { true (fails), false (passes) }.\n>     - sampleMask is being used and alphaToCoverageEnabled is { true (fails), false (passes) }.\n\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { kTextureFormats, kTextureFormatInfo } from '../../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nclass F extends ValidationTest {\n  getDescriptor(\n    options: {\n      topology?: GPUPrimitiveTopology;\n      targets?: GPUColorTargetState[];\n      sampleCount?: number;\n      depthStencil?: GPUDepthStencilState;\n    } = {}\n  ): GPURenderPipelineDescriptor {\n    const defaultTargets: GPUColorTargetState[] = [{ format: 'rgba8unorm' }];\n    const {\n      topology = 'triangle-list',\n      targets = defaultTargets,\n      sampleCount = 1,\n      depthStencil,\n    } = options;\n\n    const format = targets.length ? targets[0].format : 'rgba8unorm';\n\n    let fragColorType;\n    let suffix;\n    if (format.endsWith('sint')) {\n      fragColorType = 'i32';\n      suffix = '';\n    } else if (format.endsWith('uint')) {\n      fragColorType = 'u32';\n      suffix = 'u';\n    } else {\n      fragColorType = 'f32';\n      suffix = '.0';\n    }\n\n    return {\n      vertex: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(vertex)]] fn main() -> [[builtin(position)]] vec4<f32> {\n              return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      fragment: {\n        module: this.device.createShaderModule({\n          code: `\n            [[stage(fragment)]] fn main() -> [[location(0)]] vec4<${fragColorType}> {\n              return vec4<${fragColorType}>(0${suffix}, 1${suffix}, 0${suffix}, 1${suffix});\n            }`,\n        }),\n        entryPoint: 'main',\n        targets,\n      },\n      layout: this.getPipelineLayout(),\n      primitive: { topology },\n      multisample: { count: sampleCount },\n      depthStencil,\n    };\n  }\n\n  getPipelineLayout(): GPUPipelineLayout {\n    return this.device.createPipelineLayout({ bindGroupLayouts: [] });\n  }\n\n  createTexture(params: { format: GPUTextureFormat; sampleCount: number }): GPUTexture {\n    const { format, sampleCount } = params;\n\n    return this.device.createTexture({\n      size: { width: 4, height: 4, depthOrArrayLayers: 1 },\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      format,\n      sampleCount,\n    });\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic_use_of_createRenderPipeline').fn(t => {\n  const descriptor = t.getDescriptor();\n\n  t.device.createRenderPipeline(descriptor);\n});\n\ng.test('at_least_one_color_state_is_required').fn(async t => {\n  const goodDescriptor = t.getDescriptor({\n    targets: [{ format: 'rgba8unorm' }],\n  });\n\n  // Control case\n  t.device.createRenderPipeline(goodDescriptor);\n\n  // Fail because lack of color states\n  const badDescriptor = t.getDescriptor({\n    targets: [],\n  });\n\n  t.expectValidationError(() => {\n    t.device.createRenderPipeline(badDescriptor);\n  });\n});\n\ng.test('color_formats_must_be_renderable')\n  .params(u => u.combine('format', kTextureFormats))\n  .fn(async t => {\n    const format: GPUTextureFormat = t.params.format;\n    const info = kTextureFormatInfo[format];\n    await t.selectDeviceOrSkipTestCase(info.feature);\n\n    const descriptor = t.getDescriptor({ targets: [{ format }] });\n\n    if (info.renderable && info.color) {\n      // Succeeds when color format is renderable\n      t.device.createRenderPipeline(descriptor);\n    } else {\n      // Fails because when format is non-renderable\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n  });\n\ng.test('sample_count_must_be_valid')\n  .paramsSimple([\n    { sampleCount: 0, _success: false },\n    { sampleCount: 1, _success: true },\n    { sampleCount: 2, _success: false },\n    { sampleCount: 3, _success: false },\n    { sampleCount: 4, _success: true },\n    { sampleCount: 8, _success: false },\n    { sampleCount: 16, _success: false },\n  ])\n  .fn(async t => {\n    const { sampleCount, _success } = t.params;\n\n    const descriptor = t.getDescriptor({ sampleCount });\n\n    if (_success) {\n      // Succeeds when sample count is valid\n      t.device.createRenderPipeline(descriptor);\n    } else {\n      // Fails when sample count is not 4 or 1\n      t.expectValidationError(() => {\n        t.device.createRenderPipeline(descriptor);\n      });\n    }\n  });\n\ng.test('sample_count_must_be_equal_to_the_one_of_every_attachment_in_the_render_pass')\n  .paramsSimple([\n    { attachmentSamples: 4, pipelineSamples: 4, _success: true }, // It is allowed to use multisampled render pass and multisampled render pipeline.\n    { attachmentSamples: 4, pipelineSamples: 1, _success: false }, // It is not allowed to use multisampled render pass and non-multisampled render pipeline.\n    { attachmentSamples: 1, pipelineSamples: 4, _success: false }, // It is not allowed to use non-multisampled render pass and multisampled render pipeline.\n  ])\n  .fn(async t => {\n    const { attachmentSamples, pipelineSamples, _success } = t.params;\n\n    const colorTexture = t.createTexture({\n      format: 'rgba8unorm',\n      sampleCount: attachmentSamples,\n    });\n    const depthStencilTexture = t.createTexture({\n      format: 'depth24plus-stencil8',\n      sampleCount: attachmentSamples,\n    });\n    const renderPassDescriptorWithoutDepthStencil = {\n      colorAttachments: [\n        {\n          view: colorTexture.createView(),\n          loadValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },\n          storeOp: 'store',\n        },\n      ],\n    } as const;\n    const renderPassDescriptorWithDepthStencilOnly = {\n      colorAttachments: [],\n      depthStencilAttachment: {\n        view: depthStencilTexture.createView(),\n        depthLoadValue: 1.0,\n        depthStoreOp: 'store',\n        stencilLoadValue: 0,\n        stencilStoreOp: 'store',\n      },\n    } as const;\n\n    const pipelineWithoutDepthStencil = t.device.createRenderPipeline(\n      t.getDescriptor({\n        sampleCount: pipelineSamples,\n      })\n    );\n    const pipelineWithDepthStencilOnly = t.device.createRenderPipeline(\n      t.getDescriptor({\n        targets: [],\n        depthStencil: { format: 'depth24plus-stencil8' },\n        sampleCount: pipelineSamples,\n      })\n    );\n\n    for (const { renderPassDescriptor, pipeline } of [\n      {\n        renderPassDescriptor: renderPassDescriptorWithoutDepthStencil,\n        pipeline: pipelineWithoutDepthStencil,\n      },\n      {\n        renderPassDescriptor: renderPassDescriptorWithDepthStencilOnly,\n        pipeline: pipelineWithDepthStencilOnly,\n      },\n    ]) {\n      const commandEncoder = t.device.createCommandEncoder();\n      const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);\n      renderPass.setPipeline(pipeline);\n      renderPass.endPass();\n\n      t.expectValidationError(() => {\n        commandEncoder.finish();\n      }, !_success);\n    }\n  });\n"],"file":"createRenderPipeline.spec.js"}