{"version":3,"sources":["../../../src/webgpu/util/check_contents.ts"],"names":["assert","ErrorWithExtra","iterRange","range","checkElementsEqual","actual","expected","constructor","length","checkElementsEqualGenerated","i","checkElementsBetween","error","checkElementsPassPredicate","index","value","Math","min","max","predicatePrinter","leftHeader","getValueForCell","undefined","checkElementsEqualEither","generator","predicate","size","ctor","printAsFloat","Float32Array","Float64Array","failedElementsFirstMaybe","failedElements","failedElementsFirst","failedElementsLast","printElementsStart","printElementsEnd","printElementsCount","numberToString","n","toPrecision","intToPaddedHex","byteLength","BYTES_PER_ELEMENT","numberPrefix","printActual","subarray","printExpected","cell","push","printFailedValueMarkers","opts","fillToWidth","msg","generatePrettyTable","slice","number","Number","isInteger","s","abs","toString","padStart","rows","rowStrings","totalTableWidth","iters","map","row","Symbol","iterator","cellsForColumn","iter","r","next","done","every","colWidth","c","join"],"mappings":"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","sourcesContent":["import {\n  assert,\n  ErrorWithExtra,\n  iterRange,\n  range,\n  TypedArrayBufferView,\n  TypedArrayBufferViewConstructor,\n} from '../../common/util/util.js';\n\n/** Generate an expected value at `index`, to test for equality with the actual value. */\nexport type CheckElementsGenerator = (index: number) => number;\n/** Check whether the actual `value` at `index` is as expected. */\nexport type CheckElementsPredicate = (index: number, value: number) => boolean;\n/**\n * Provides a pretty-printing implementation for a particular CheckElementsPredicate.\n * This is an array; each element provides info to print an additional row in the error message.\n */\nexport type CheckElementsSupplementalTableRows = ReadonlyArray<{\n  /** Row header. */\n  leftHeader: string;\n  /** Get the value for a cell in the table with TypedArray element index `index`. */\n  getValueForCell: (index: number) => number;\n}>;\n\n/**\n * Check whether two `TypedArray`s have equal contents.\n * Returns `undefined` if the check passes, or an `Error` if not.\n */\nexport function checkElementsEqual(\n  actual: TypedArrayBufferView,\n  expected: TypedArrayBufferView\n): ErrorWithExtra | undefined {\n  assert(actual.constructor === expected.constructor, 'TypedArray type mismatch');\n  assert(actual.length === expected.length, 'size mismatch');\n  return checkElementsEqualGenerated(actual, i => expected[i]);\n}\n\n/**\n * Check whether each value in a `TypedArray` is between the two corresponding \"expected\" values\n * (either `a[i] <= actual[i] <= b[i]` or `a[i] >= actual[i] => b[i]`).\n */\nexport function checkElementsBetween(\n  actual: TypedArrayBufferView,\n  expected: readonly [TypedArrayBufferView, TypedArrayBufferView]\n): ErrorWithExtra | undefined {\n  const error = checkElementsPassPredicate(\n    actual,\n    (index, value) =>\n      value >= Math.min(expected[0][index], expected[1][index]) &&\n      value <= Math.max(expected[0][index], expected[1][index]),\n    {\n      predicatePrinter: [\n        { leftHeader: 'between', getValueForCell: index => expected[0][index] },\n        { leftHeader: 'and', getValueForCell: index => expected[1][index] },\n      ],\n    }\n  );\n  // If there was an error, extend it with additional extras.\n  return error ? new ErrorWithExtra(error, () => ({ expected })) : undefined;\n}\n\n/**\n * Check whether each value in a `TypedArray` is equal to one of the two corresponding \"expected\"\n * values (either `actual[i] === a[i]` or `actual[i] === b[i]`)\n */\nexport function checkElementsEqualEither(\n  actual: TypedArrayBufferView,\n  expected: readonly [TypedArrayBufferView, TypedArrayBufferView]\n): ErrorWithExtra | undefined {\n  const error = checkElementsPassPredicate(\n    actual,\n    (index, value) => value === expected[0][index] || value === expected[1][index],\n    {\n      predicatePrinter: [\n        { leftHeader: 'either', getValueForCell: index => expected[0][index] },\n        { leftHeader: 'or', getValueForCell: index => expected[1][index] },\n      ],\n    }\n  );\n  // If there was an error, extend it with additional extras.\n  return error ? new ErrorWithExtra(error, () => ({ expected })) : undefined;\n}\n\n/**\n * Check whether a `TypedArray`'s contents equal the values produced by a generator function.\n * Returns `undefined` if the check passes, or an `Error` if not.\n *\n * ```text\n * Array had unexpected contents at indices 2 through 19.\n *  Starting at index 1:\n *    actual == 0x: 00 fe ff 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00\n *    failed ->        xx xx    xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx\n *  expected ==     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n * ```\n *\n * ```text\n * Array had unexpected contents at indices 2 through 29.\n *  Starting at index 1:\n *    actual ==  0.000 -2.000e+100 -1.000e+100 0.000 1.000e+100 2.000e+100 3.000e+100 4.000e+100 5.000e+100 6.000e+100 7.000e+100 ...\n *    failed ->                 xx          xx               xx         xx         xx         xx         xx         xx         xx ...\n *  expected ==  0.000       0.000       0.000 0.000      0.000      0.000      0.000      0.000      0.000      0.000      0.000 ...\n * ```\n */\nexport function checkElementsEqualGenerated(\n  actual: TypedArrayBufferView,\n  generator: CheckElementsGenerator\n): ErrorWithExtra | undefined {\n  const error = checkElementsPassPredicate(actual, (index, value) => value === generator(index), {\n    predicatePrinter: [{ leftHeader: 'expected ==', getValueForCell: index => generator(index) }],\n  });\n  // If there was an error, extend it with additional extras.\n  return error ? new ErrorWithExtra(error, () => ({ generator })) : undefined;\n}\n\n/**\n * Check whether a `TypedArray`'s values pass the provided predicate function.\n * Returns `undefined` if the check passes, or an `Error` if not.\n */\nexport function checkElementsPassPredicate(\n  actual: TypedArrayBufferView,\n  predicate: CheckElementsPredicate,\n  { predicatePrinter }: { predicatePrinter?: CheckElementsSupplementalTableRows }\n): ErrorWithExtra | undefined {\n  const size = actual.length;\n  const ctor = actual.constructor as TypedArrayBufferViewConstructor;\n  const printAsFloat = ctor === Float32Array || ctor === Float64Array;\n\n  let failedElementsFirstMaybe: number | undefined = undefined;\n  /** Sparse array with `true` for elements that failed. */\n  const failedElements: (true | undefined)[] = [];\n  for (let i = 0; i < size; ++i) {\n    if (!predicate(i, actual[i])) {\n      failedElementsFirstMaybe ??= i;\n      failedElements[i] = true;\n    }\n  }\n\n  if (failedElementsFirstMaybe === undefined) {\n    return undefined;\n  }\n  const failedElementsFirst = failedElementsFirstMaybe;\n  const failedElementsLast = failedElements.length - 1;\n\n  // Include one extra non-failed element at the beginning and end (if they exist), for context.\n  const printElementsStart = Math.max(0, failedElementsFirst - 1);\n  const printElementsEnd = Math.min(size, failedElementsLast + 2);\n  const printElementsCount = printElementsEnd - printElementsStart;\n\n  const numberToString = printAsFloat\n    ? (n: number) => n.toPrecision(4)\n    : (n: number) => intToPaddedHex(n, { byteLength: ctor.BYTES_PER_ELEMENT });\n  const numberPrefix = printAsFloat ? '' : '0x:';\n\n  const printActual = actual.subarray(printElementsStart, printElementsEnd);\n  const printExpected: Array<Iterable<string | number>> = [];\n  if (predicatePrinter) {\n    for (const { leftHeader, getValueForCell: cell } of predicatePrinter) {\n      printExpected.push(\n        (function* () {\n          yield* [leftHeader, ''];\n          yield* iterRange(printElementsCount, i => cell(printElementsStart + i));\n        })()\n      );\n    }\n  }\n\n  const printFailedValueMarkers = (function* () {\n    yield* ['failed ->', ''];\n    yield* range(printElementsCount, i => (failedElements[printElementsStart + i] ? 'xx' : ''));\n  })();\n\n  const opts = {\n    fillToWidth: 120,\n    numberToString,\n  };\n  const msg = `Array had unexpected contents at indices ${failedElementsFirst} through ${failedElementsLast}.\n Starting at index ${printElementsStart}:\n${generatePrettyTable(opts, [\n  ['actual ==', numberPrefix, ...printActual],\n  printFailedValueMarkers,\n  ...printExpected,\n])}`;\n  return new ErrorWithExtra(msg, () => ({\n    actual: actual.slice(),\n  }));\n}\n\n// Helper helpers\n\n/** Convert an integral `number` into a hex string, padded to the specified `byteLength`. */\nfunction intToPaddedHex(number: number, { byteLength }: { byteLength: number }) {\n  assert(Number.isInteger(number), 'number must be integer');\n  let s = Math.abs(number).toString(16);\n  if (byteLength) s = s.padStart(byteLength * 2, '0');\n  if (number < 0) s = '-' + s;\n  return s;\n}\n\n/**\n * Pretty-prints a \"table\" of cell values (each being `number | string`), right-aligned.\n * Each row may be any iterator, including lazily-generated (potentially infinite) rows.\n *\n * The first argument is the printing options:\n *  - fillToWidth: Keep printing columns (as long as there is data) until this width is passed.\n *    If there is more data, \"...\" is appended.\n *  - numberToString: if a cell value is a number, this is used to stringify it.\n *\n * Each remaining argument provides one row for the table.\n */\nfunction generatePrettyTable(\n  { fillToWidth, numberToString }: { fillToWidth: number; numberToString: (n: number) => string },\n  rows: ReadonlyArray<Iterable<string | number>>\n): string {\n  const rowStrings = range(rows.length, () => '');\n  let totalTableWidth = 0;\n  const iters = rows.map(row => row[Symbol.iterator]());\n\n  // Loop over columns\n  for (;;) {\n    const cellsForColumn = iters.map(iter => {\n      const r = iter.next(); // Advance the iterator for each row, in lock-step.\n      return r.done ? undefined : typeof r.value === 'number' ? numberToString(r.value) : r.value;\n    });\n    if (cellsForColumn.every(cell => cell === undefined)) break;\n\n    // Maximum width of any cell in this column, plus one for space between columns\n    // (also inserts a space at the left of the first column).\n    const colWidth = Math.max(...cellsForColumn.map(c => (c === undefined ? 0 : c.length))) + 1;\n    for (let row = 0; row < rowStrings.length; ++row) {\n      const cell = cellsForColumn[row];\n      if (cell !== undefined) {\n        rowStrings[row] += cell.padStart(colWidth);\n      }\n    }\n\n    totalTableWidth += colWidth;\n    if (totalTableWidth >= fillToWidth) {\n      for (let row = 0; row < rowStrings.length; ++row) {\n        if (cellsForColumn[row] !== undefined) {\n          rowStrings[row] += ' ...';\n        }\n      }\n      break;\n    }\n  }\n  return rowStrings.join('\\n');\n}\n"],"file":"check_contents.js"}