{"version":3,"sources":["../../../src/webgpu/util/copyToTexture.ts"],"names":["GPUTest","checkElementsEqual","align","kBytesPerRowAlignment","CopyToTextureUtils","checkCopyExternalImageResult","src","expected","width","height","bytesPerPixel","exp","Uint8Array","buffer","byteOffset","byteLength","rowPitch","dst","createCopyForMapRead","eventualAsyncExpectation","niceStack","mapAsync","GPUMapMode","READ","actual","getMappedRange","check","checkBufferWithRowPitch","undefined","message","rec","expectationFailed","destroy","bytesPerRow","y","checkResult","subarray","doTestAndCheckResult","imageCopyExternalImage","dstTextureCopyView","copySize","expectedData","device","queue","copyExternalImageToTexture","externalImage","source","dstTexture","texture","testBuffer","createBuffer","size","usage","GPUBufferUsage","COPY_SRC","COPY_DST","encoder","createCommandEncoder","copyTextureToBuffer","mipLevel","origin","x","z","depthOrArrayLayers","submit","finish"],"mappings":";AAAA;AACA,GADA,SAASA,OAAT,QAAwB,gBAAxB,CAEA,SAASC,kBAAT,QAAmC,qBAAnC;AACA,SAASC,KAAT,QAAsB,WAAtB;AACA,SAASC,qBAAT,QAAsC,qBAAtC;;AAEA,OAAO,MAAMC,kBAAN,SAAiCJ,OAAjC,CAAyC;AAC9CK,EAAAA,4BAA4B;AAC1BC,EAAAA,GAD0B;AAE1BC,EAAAA,QAF0B;AAG1BC,EAAAA,KAH0B;AAI1BC,EAAAA,MAJ0B;AAK1BC,EAAAA,aAL0B;AAMpB;AACN,UAAMC,GAAG,GAAG,IAAIC,UAAJ,CAAeL,QAAQ,CAACM,MAAxB,EAAgCN,QAAQ,CAACO,UAAzC,EAAqDP,QAAQ,CAACQ,UAA9D,CAAZ;AACA,UAAMC,QAAQ,GAAGd,KAAK,CAACM,KAAK,GAAGE,aAAT,EAAwBP,qBAAxB,CAAtB;AACA,UAAMc,GAAG,GAAG,KAAKC,oBAAL,CAA0BZ,GAA1B,EAA+B,CAA/B,EAAkCU,QAAQ,GAAGP,MAA7C,CAAZ;;AAEA,SAAKU,wBAAL,CAA8B,MAAMC,SAAN,IAAmB;AAC/C,YAAMH,GAAG,CAACI,QAAJ,CAAaC,UAAU,CAACC,IAAxB,CAAN;AACA,YAAMC,MAAM,GAAG,IAAIZ,UAAJ,CAAeK,GAAG,CAACQ,cAAJ,EAAf,CAAf;AACA,YAAMC,KAAK,GAAG,KAAKC,uBAAL;AACZH,MAAAA,MADY;AAEZb,MAAAA,GAFY;AAGZH,MAAAA,KAHY;AAIZC,MAAAA,MAJY;AAKZO,MAAAA,QALY;AAMZN,MAAAA,aANY,CAAd;;AAQA,UAAIgB,KAAK,KAAKE,SAAd,EAAyB;AACvBR,QAAAA,SAAS,CAACS,OAAV,GAAoBH,KAApB;AACA,aAAKI,GAAL,CAASC,iBAAT,CAA2BX,SAA3B;AACD;AACDH,MAAAA,GAAG,CAACe,OAAJ;AACD,KAhBD;AAiBD;;AAED;AACAL,EAAAA,uBAAuB;AACrBH,EAAAA,MADqB;AAErBb,EAAAA,GAFqB;AAGrBH,EAAAA,KAHqB;AAIrBC,EAAAA,MAJqB;AAKrBO,EAAAA,QALqB;AAMrBN,EAAAA,aANqB;AAOD;AACpB,UAAMuB,WAAW,GAAGzB,KAAK,GAAGE,aAA5B;AACA,SAAK,IAAIwB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,MAApB,EAA4B,EAAEyB,CAA9B,EAAiC;AAC/B,YAAMC,WAAW,GAAGlC,kBAAkB;AACpCuB,MAAAA,MAAM,CAACY,QAAP,CAAgBF,CAAC,GAAGlB,QAApB,EAA8BiB,WAA9B,CADoC;AAEpCtB,MAAAA,GAAG,CAACyB,QAAJ,CAAaF,CAAC,GAAGD,WAAjB,EAA8BA,WAA9B,CAFoC,CAAtC;;AAIA,UAAIE,WAAW,KAAKP,SAApB,EAA+B,OAAQ,UAASM,CAAE,KAAIC,WAAY,EAAnC;AAChC;AACD,WAAOP,SAAP;AACD;;AAEDS,EAAAA,oBAAoB;AAClBC,EAAAA,sBADkB;AAElBC,EAAAA,kBAFkB;AAGlBC,EAAAA,QAHkB;AAIlB9B,EAAAA,aAJkB;AAKlB+B,EAAAA,YALkB;AAMZ;AACN,SAAKC,MAAL,CAAYC,KAAZ,CAAkBC,0BAAlB;AACEN,IAAAA,sBADF;AAEEC,IAAAA,kBAFF;AAGEC,IAAAA,QAHF;;;AAMA,UAAMK,aAAa,GAAGP,sBAAsB,CAACQ,MAA7C;AACA,UAAMC,UAAU,GAAGR,kBAAkB,CAACS,OAAtC;;AAEA,UAAMf,WAAW,GAAG/B,KAAK,CAAC2C,aAAa,CAACrC,KAAd,GAAsBE,aAAvB,EAAsCP,qBAAtC,CAAzB;AACA,UAAM8C,UAAU,GAAG,KAAKP,MAAL,CAAYQ,YAAZ,CAAyB;AAC1CC,MAAAA,IAAI,EAAElB,WAAW,GAAGY,aAAa,CAACpC,MADQ;AAE1C2C,MAAAA,KAAK,EAAEC,cAAc,CAACC,QAAf,GAA0BD,cAAc,CAACE,QAFN,EAAzB,CAAnB;;;AAKA,UAAMC,OAAO,GAAG,KAAKd,MAAL,CAAYe,oBAAZ,EAAhB;;AAEAD,IAAAA,OAAO,CAACE,mBAAR;AACE,MAAEV,OAAO,EAAED,UAAX,EAAuBY,QAAQ,EAAE,CAAjC,EAAoCC,MAAM,EAAE,EAAEC,CAAC,EAAE,CAAL,EAAQ3B,CAAC,EAAE,CAAX,EAAc4B,CAAC,EAAE,CAAjB,EAA5C,EADF;AAEE,MAAEjD,MAAM,EAAEoC,UAAV,EAAsBhB,WAAtB,EAFF;AAGE,MAAEzB,KAAK,EAAEqC,aAAa,CAACrC,KAAvB,EAA8BC,MAAM,EAAEoC,aAAa,CAACpC,MAApD,EAA4DsD,kBAAkB,EAAE,CAAhF,EAHF;;AAKA,SAAKrB,MAAL,CAAYC,KAAZ,CAAkBqB,MAAlB,CAAyB,CAACR,OAAO,CAACS,MAAR,EAAD,CAAzB;;AAEA,SAAK5D,4BAAL;AACE4C,IAAAA,UADF;AAEER,IAAAA,YAFF;AAGEI,IAAAA,aAAa,CAACrC,KAHhB;AAIEqC,IAAAA,aAAa,CAACpC,MAJhB;AAKEC,IAAAA,aALF;;AAOD,GAzF6C","sourcesContent":["import { GPUTest } from '../gpu_test.js';\n\nimport { checkElementsEqual } from './check_contents.js';\nimport { align } from './math.js';\nimport { kBytesPerRowAlignment } from './texture/layout.js';\n\nexport class CopyToTextureUtils extends GPUTest {\n  checkCopyExternalImageResult(\n    src: GPUBuffer,\n    expected: ArrayBufferView,\n    width: number,\n    height: number,\n    bytesPerPixel: number\n  ): void {\n    const exp = new Uint8Array(expected.buffer, expected.byteOffset, expected.byteLength);\n    const rowPitch = align(width * bytesPerPixel, kBytesPerRowAlignment);\n    const dst = this.createCopyForMapRead(src, 0, rowPitch * height);\n\n    this.eventualAsyncExpectation(async niceStack => {\n      await dst.mapAsync(GPUMapMode.READ);\n      const actual = new Uint8Array(dst.getMappedRange());\n      const check = this.checkBufferWithRowPitch(\n        actual,\n        exp,\n        width,\n        height,\n        rowPitch,\n        bytesPerPixel\n      );\n      if (check !== undefined) {\n        niceStack.message = check;\n        this.rec.expectationFailed(niceStack);\n      }\n      dst.destroy();\n    });\n  }\n\n  // TODO(crbug.com/dawn/868): Should be possible to consolidate this along with texture checking\n  checkBufferWithRowPitch(\n    actual: Uint8Array,\n    exp: Uint8Array,\n    width: number,\n    height: number,\n    rowPitch: number,\n    bytesPerPixel: number\n  ): string | undefined {\n    const bytesPerRow = width * bytesPerPixel;\n    for (let y = 0; y < height; ++y) {\n      const checkResult = checkElementsEqual(\n        actual.subarray(y * rowPitch, bytesPerRow),\n        exp.subarray(y * bytesPerRow, bytesPerRow)\n      );\n      if (checkResult !== undefined) return `on row ${y}: ${checkResult}`;\n    }\n    return undefined;\n  }\n\n  doTestAndCheckResult(\n    imageCopyExternalImage: GPUImageCopyExternalImage,\n    dstTextureCopyView: GPUImageCopyTexture,\n    copySize: GPUExtent3DDict,\n    bytesPerPixel: number,\n    expectedData: Uint8ClampedArray\n  ): void {\n    this.device.queue.copyExternalImageToTexture(\n      imageCopyExternalImage,\n      dstTextureCopyView,\n      copySize\n    );\n\n    const externalImage = imageCopyExternalImage.source;\n    const dstTexture = dstTextureCopyView.texture;\n\n    const bytesPerRow = align(externalImage.width * bytesPerPixel, kBytesPerRowAlignment);\n    const testBuffer = this.device.createBuffer({\n      size: bytesPerRow * externalImage.height,\n      usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    });\n\n    const encoder = this.device.createCommandEncoder();\n\n    encoder.copyTextureToBuffer(\n      { texture: dstTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } },\n      { buffer: testBuffer, bytesPerRow },\n      { width: externalImage.width, height: externalImage.height, depthOrArrayLayers: 1 }\n    );\n    this.device.queue.submit([encoder.finish()]);\n\n    this.checkCopyExternalImageResult(\n      testBuffer,\n      expectedData,\n      externalImage.width,\n      externalImage.height,\n      bytesPerPixel\n    );\n  }\n}\n"],"file":"copyToTexture.js"}