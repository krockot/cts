{"version":3,"sources":["../../../../src/webgpu/web_platform/copyToTexture/canvas.spec.ts"],"names":["description","makeTestGroup","unreachable","kTextureFormatInfo","kValidTextureFormatsForCopyIB2T","CopyToTextureUtils","kTexelRepresentationInfo","F","initCanvasContent","canvasType","contextName","width","height","canvas","document","createElement","skip","OffscreenCanvas","canvasContext","getContext","contextType","rectWidth","Math","floor","rectHeight","ctx","fillStyle","fillRect","gl","enable","SCISSOR_TEST","scissor","clearColor","clear","COLOR_BUFFER_BIT","getExpectedPixels","context","format","bytesPerPixel","bytesPerBlock","expectedPixels","Uint8ClampedArray","sourcePixels","getImageData","data","readPixels","RGBA","UNSIGNED_BYTE","rep","divide","i","j","pixelPos","pixelData","Uint8Array","pack","encode","R","G","B","A","set","g","test","desc","params","u","combine","beginSubcases","fn","t","dstColorFormat","dst","device","createTexture","size","depthOrArrayLayers","usage","GPUTextureUsage","COPY_DST","COPY_SRC","RENDER_ATTACHMENT","dstBytesPerPixel","doTestAndCheckResult","source","origin","x","y","texture"],"mappings":"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","sourcesContent":["export const description = `\ncopyToTexture with HTMLCanvasElement and OffscreenCanvas sources.\n\nTODO: consider whether external_texture and copyToTexture video tests should be in the same file\n`;\n\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport { unreachable } from '../../../common/util/util.js';\nimport {\n  RegularTextureFormat,\n  kTextureFormatInfo,\n  kValidTextureFormatsForCopyIB2T,\n} from '../../capability_info.js';\nimport { CopyToTextureUtils } from '../../util/copyToTexture.js';\nimport { kTexelRepresentationInfo } from '../../util/texture/texel_data.js';\n\nclass F extends CopyToTextureUtils {\n  initCanvasContent({\n    canvasType,\n    contextName,\n    width,\n    height,\n  }: {\n    canvasType: 'onscreen' | 'offscreen';\n    contextName: '2d' | 'webgl' | 'webgl2';\n    width: number;\n    height: number;\n  }): {\n    canvas: HTMLCanvasElement | OffscreenCanvas;\n    canvasContext:\n      | WebGLRenderingContext\n      | WebGL2RenderingContext\n      | CanvasRenderingContext2D\n      | OffscreenCanvasRenderingContext2D;\n  } {\n    let canvas: HTMLCanvasElement | OffscreenCanvas | null = null;\n    if (canvasType === 'onscreen') {\n      if (typeof document !== 'undefined') {\n        canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        this.skip('Cannot create HTMLCanvasElement');\n      }\n    } else if (canvasType === 'offscreen') {\n      if (typeof OffscreenCanvas === 'undefined') {\n        this.skip('OffscreenCanvas is not supported');\n      }\n      canvas = new OffscreenCanvas(width, height);\n    } else {\n      unreachable();\n    }\n\n    if (canvas === null) {\n      this.skip('Cannot create canvas');\n    }\n\n    const canvasContext = canvas.getContext(contextName) as\n      | WebGLRenderingContext\n      | WebGL2RenderingContext\n      | CanvasRenderingContext2D\n      | OffscreenCanvasRenderingContext2D\n      | null;\n    if (canvasContext === null) {\n      this.skip(canvasType + ' canvas context not available');\n    }\n\n    const contextType: '2d' | 'gl' = contextName === '2d' ? '2d' : 'gl';\n\n    const rectWidth = Math.floor(width / 2);\n    const rectHeight = Math.floor(height / 2);\n    if (contextType === '2d') {\n      const ctx = canvasContext as CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n      ctx.fillStyle = '#ff0000'; // red\n      ctx.fillRect(0, 0, rectWidth, rectHeight);\n      ctx.fillStyle = '#00ff00'; // lime\n      ctx.fillRect(rectWidth, 0, width - rectWidth, rectHeight);\n      ctx.fillStyle = '#0000ff'; // blue\n      ctx.fillRect(0, rectHeight, rectWidth, height - rectHeight);\n      ctx.fillStyle = '#000000'; // black\n      ctx.fillRect(rectWidth, rectHeight, width - rectWidth, height - rectHeight);\n    } else if (contextType === 'gl') {\n      const gl = canvasContext as WebGLRenderingContext | WebGL2RenderingContext;\n      gl.enable(gl.SCISSOR_TEST);\n      gl.scissor(0, 0, rectWidth, rectHeight);\n      gl.clearColor(1.0, 0.0, 0.0, 1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      gl.scissor(rectWidth, 0, width - rectWidth, rectHeight);\n      gl.clearColor(0.0, 1.0, 0.0, 1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      gl.scissor(0, rectHeight, rectWidth, height - rectHeight);\n      gl.clearColor(0.0, 0.0, 1.0, 1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      gl.scissor(rectWidth, rectHeight, width - rectWidth, height - rectHeight);\n      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    return { canvas, canvasContext };\n  }\n\n  getExpectedPixels({\n    context,\n    width,\n    height,\n    format,\n    contextType,\n  }: {\n    context:\n      | CanvasRenderingContext2D\n      | OffscreenCanvasRenderingContext2D\n      | WebGLRenderingContext\n      | WebGL2RenderingContext;\n    width: number;\n    height: number;\n    format: RegularTextureFormat;\n    contextType: '2d' | 'gl';\n  }): Uint8ClampedArray {\n    const bytesPerPixel = kTextureFormatInfo[format].bytesPerBlock;\n\n    const expectedPixels = new Uint8ClampedArray(bytesPerPixel * width * height);\n    let sourcePixels;\n    if (contextType === '2d') {\n      const ctx = context as CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n      sourcePixels = ctx.getImageData(0, 0, width, height).data;\n    } else if (contextType === 'gl') {\n      sourcePixels = new Uint8ClampedArray(width * height * 4);\n      const gl = context as WebGLRenderingContext | WebGL2RenderingContext;\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, sourcePixels);\n    } else {\n      unreachable();\n    }\n\n    // Generate expectedPixels\n    const rep = kTexelRepresentationInfo[format];\n    const divide = 255.0;\n    for (let i = 0; i < height; ++i) {\n      for (let j = 0; j < width; ++j) {\n        const pixelPos = i * width + j;\n        const pixelData = new Uint8Array(\n          rep.pack(\n            rep.encode({\n              R: sourcePixels[pixelPos * 4] / divide,\n              G: sourcePixels[pixelPos * 4 + 1] / divide,\n              B: sourcePixels[pixelPos * 4 + 2] / divide,\n              A: sourcePixels[pixelPos * 4 + 3] / divide,\n            })\n          )\n        );\n        expectedPixels.set(pixelData, pixelPos * bytesPerPixel);\n      }\n    }\n\n    return expectedPixels;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('copy_contents_from_canvas')\n  .desc(\n    `\n  Test HTMLCanvasElement and OffscreenCanvas with 2d/webgl/webgl2 context\n  can be copied to WebGPU texture correctly.\n\n  It creates HTMLCanvasElement/OffscreenCanvas with '2d'/'webgl'/'webgl2'.\n  Use fillRect(2d context) or stencil + clear (gl context) to rendering\n  red rect for top-left, green rect for top-right, blue rect for bottom-left\n  and black for bottom-right.\n  Then call copyExternalImageToTexture() to do a full copy to the 0 mipLevel\n  of dst texture, and read the contents out to compare with the canvas contents.\n\n  The tests covers:\n  - Valid canvas type\n  - Valid context type\n  - TODO: premultiplied alpha tests need to be added.\n  - TODO: color space tests need to be added\n\n  And the expected results are all passed.\n  `\n  )\n  .params(u =>\n    u\n      .combine('canvasType', ['onscreen', 'offscreen'] as const)\n      .combine('contextName', ['2d', 'webgl', 'webgl2'] as const)\n      .combine('dstColorFormat', kValidTextureFormatsForCopyIB2T)\n      .beginSubcases()\n      .combine('width', [1, 2, 4, 15, 255, 256])\n      .combine('height', [1, 2, 4, 15, 255, 256])\n  )\n  .fn(async t => {\n    const { width, height, canvasType, contextName, dstColorFormat } = t.params;\n\n    const { canvas, canvasContext } = t.initCanvasContent({\n      canvasType,\n      contextName,\n      width,\n      height,\n    });\n\n    const dst = t.device.createTexture({\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 1,\n      },\n      format: dstColorFormat,\n      usage:\n        GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    // Construct expected value for different dst color format\n    const dstBytesPerPixel = kTextureFormatInfo[dstColorFormat].bytesPerBlock;\n    const expectedPixels = t.getExpectedPixels({\n      context: canvasContext,\n      width,\n      height,\n      format: dstColorFormat,\n      contextType: contextName === '2d' ? '2d' : 'gl',\n    });\n\n    t.doTestAndCheckResult(\n      { source: canvas, origin: { x: 0, y: 0 } },\n      { texture: dst },\n      { width: canvas.width, height: canvas.height, depthOrArrayLayers: 1 },\n      dstBytesPerPixel,\n      expectedPixels\n    );\n  });\n"],"file":"canvas.spec.js"}